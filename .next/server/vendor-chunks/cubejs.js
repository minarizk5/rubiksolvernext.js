/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cubejs";
exports.ids = ["vendor-chunks/cubejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/cubejs/index.js":
/*!**************************************!*\
  !*** ./node_modules/cubejs/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/cube */ \"(ssr)/./node_modules/cubejs/lib/cube.js\");\n__webpack_require__(/*! ./lib/solve */ \"(ssr)/./node_modules/cubejs/lib/solve.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3ViZWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGlHQUFzQztBQUN0QyxtQkFBTyxDQUFDLDZEQUFhIiwic291cmNlcyI6WyIvVXNlcnMvbWluYXJpemsvRG93bmxvYWRzL3J1YmlrbmV4dC9ub2RlX21vZHVsZXMvY3ViZWpzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvY3ViZScpO1xucmVxdWlyZSgnLi9saWIvc29sdmUnKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cubejs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cubejs/lib/cube.js":
/*!*****************************************!*\
  !*** ./node_modules/cubejs/lib/cube.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function() {\n  // Centers\n  var B, BL, BR, Cube, D, DB, DBL, DF, DFR, DL, DLF, DR, DRB, F, FL, FR, L, R, U, UB, UBR, UF, UFL, UL, ULB, UR, URF, centerColor, centerFacelet, cornerColor, cornerFacelet, edgeColor, edgeFacelet;\n\n  [U, R, F, D, L, B] = [0, 1, 2, 3, 4, 5];\n\n  // Corners\n  [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB] = [0, 1, 2, 3, 4, 5, 6, 7];\n\n  // Edges\n  [UR, UF, UL, UB, DR, DF, DL, DB, FR, FL, BL, BR] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\n  [centerFacelet, cornerFacelet, edgeFacelet] = (function() {\n    var _B, _D, _F, _L, _R, _U;\n    _U = function(x) {\n      return x - 1;\n    };\n    _R = function(x) {\n      return _U(9) + x;\n    };\n    _F = function(x) {\n      return _R(9) + x;\n    };\n    _D = function(x) {\n      return _F(9) + x;\n    };\n    _L = function(x) {\n      return _D(9) + x;\n    };\n    _B = function(x) {\n      return _L(9) + x;\n    };\n    return [\n      // Centers\n      [4,\n      13,\n      22,\n      31,\n      40,\n      49],\n      // Corners\n      [[_U(9),\n      _R(1),\n      _F(3)],\n      [_U(7),\n      _F(1),\n      _L(3)],\n      [_U(1),\n      _L(1),\n      _B(3)],\n      [_U(3),\n      _B(1),\n      _R(3)],\n      [_D(3),\n      _F(9),\n      _R(7)],\n      [_D(1),\n      _L(9),\n      _F(7)],\n      [_D(7),\n      _B(9),\n      _L(7)],\n      [_D(9),\n      _R(9),\n      _B(7)]],\n      // Edges\n      [[_U(6),\n      _R(2)],\n      [_U(8),\n      _F(2)],\n      [_U(4),\n      _L(2)],\n      [_U(2),\n      _B(2)],\n      [_D(6),\n      _R(8)],\n      [_D(2),\n      _F(8)],\n      [_D(4),\n      _L(8)],\n      [_D(8),\n      _B(8)],\n      [_F(6),\n      _R(4)],\n      [_F(4),\n      _L(6)],\n      [_B(6),\n      _L(4)],\n      [_B(4),\n      _R(6)]]\n    ];\n  })();\n\n  centerColor = ['U', 'R', 'F', 'D', 'L', 'B'];\n\n  cornerColor = [['U', 'R', 'F'], ['U', 'F', 'L'], ['U', 'L', 'B'], ['U', 'B', 'R'], ['D', 'F', 'R'], ['D', 'L', 'F'], ['D', 'B', 'L'], ['D', 'R', 'B']];\n\n  edgeColor = [['U', 'R'], ['U', 'F'], ['U', 'L'], ['U', 'B'], ['D', 'R'], ['D', 'F'], ['D', 'L'], ['D', 'B'], ['F', 'R'], ['F', 'L'], ['B', 'L'], ['B', 'R']];\n\n  Cube = (function() {\n    var faceNames, faceNums, parseAlg;\n\n    class Cube {\n      constructor(other) {\n        var x;\n        if (other != null) {\n          this.init(other);\n        } else {\n          this.identity();\n        }\n        // For moves to avoid allocating new objects each time\n        this.newCenter = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 5; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newCp = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 7; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newEp = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 11; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newCo = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 7; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newEo = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 11; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n      }\n\n      init(state) {\n        this.center = state.center.slice(0);\n        this.co = state.co.slice(0);\n        this.ep = state.ep.slice(0);\n        this.cp = state.cp.slice(0);\n        return this.eo = state.eo.slice(0);\n      }\n\n      identity() {\n        var x;\n        // Initialize to the identity cube\n        this.center = [0, 1, 2, 3, 4, 5];\n        this.cp = [0, 1, 2, 3, 4, 5, 6, 7];\n        this.co = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 7; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.ep = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n        return this.eo = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 11; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n      }\n\n      toJSON() {\n        return {\n          center: this.center,\n          cp: this.cp,\n          co: this.co,\n          ep: this.ep,\n          eo: this.eo\n        };\n      }\n\n      asString() {\n        var corner, edge, i, k, l, m, n, o, ori, p, result;\n        result = [];\n        for (i = k = 0; k <= 5; i = ++k) {\n          result[9 * i + 4] = centerColor[this.center[i]];\n        }\n        for (i = l = 0; l <= 7; i = ++l) {\n          corner = this.cp[i];\n          ori = this.co[i];\n          for (n = m = 0; m <= 2; n = ++m) {\n            result[cornerFacelet[i][(n + ori) % 3]] = cornerColor[corner][n];\n          }\n        }\n        for (i = o = 0; o <= 11; i = ++o) {\n          edge = this.ep[i];\n          ori = this.eo[i];\n          for (n = p = 0; p <= 1; n = ++p) {\n            result[edgeFacelet[i][(n + ori) % 2]] = edgeColor[edge][n];\n          }\n        }\n        return result.join('');\n      }\n\n      static fromString(str) {\n        var col1, col2, cube, i, j, k, l, m, o, ori, p, q, r, ref;\n        cube = new Cube;\n        for (i = k = 0; k <= 5; i = ++k) {\n          for (j = l = 0; l <= 5; j = ++l) {\n            if (str[9 * i + 4] === centerColor[j]) {\n              cube.center[i] = j;\n            }\n          }\n        }\n        for (i = m = 0; m <= 7; i = ++m) {\n          for (ori = o = 0; o <= 2; ori = ++o) {\n            if ((ref = str[cornerFacelet[i][ori]]) === 'U' || ref === 'D') {\n              break;\n            }\n          }\n          col1 = str[cornerFacelet[i][(ori + 1) % 3]];\n          col2 = str[cornerFacelet[i][(ori + 2) % 3]];\n          for (j = p = 0; p <= 7; j = ++p) {\n            if (col1 === cornerColor[j][1] && col2 === cornerColor[j][2]) {\n              cube.cp[i] = j;\n              cube.co[i] = ori % 3;\n            }\n          }\n        }\n        for (i = q = 0; q <= 11; i = ++q) {\n          for (j = r = 0; r <= 11; j = ++r) {\n            if (str[edgeFacelet[i][0]] === edgeColor[j][0] && str[edgeFacelet[i][1]] === edgeColor[j][1]) {\n              cube.ep[i] = j;\n              cube.eo[i] = 0;\n              break;\n            }\n            if (str[edgeFacelet[i][0]] === edgeColor[j][1] && str[edgeFacelet[i][1]] === edgeColor[j][0]) {\n              cube.ep[i] = j;\n              cube.eo[i] = 1;\n              break;\n            }\n          }\n        }\n        return cube;\n      }\n\n      clone() {\n        return new Cube(this.toJSON());\n      }\n\n      // A class method returning a new random cube\n      static random() {\n        return new Cube().randomize();\n      }\n\n      isSolved() {\n        var c, cent, clone, e, k, l, m;\n        clone = this.clone();\n        clone.move(clone.upright());\n        for (cent = k = 0; k <= 5; cent = ++k) {\n          if (clone.center[cent] !== cent) {\n            return false;\n          }\n        }\n        for (c = l = 0; l <= 7; c = ++l) {\n          if (clone.cp[c] !== c) {\n            return false;\n          }\n          if (clone.co[c] !== 0) {\n            return false;\n          }\n        }\n        for (e = m = 0; m <= 11; e = ++m) {\n          if (clone.ep[e] !== e) {\n            return false;\n          }\n          if (clone.eo[e] !== 0) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      // Multiply this Cube with another Cube, restricted to centers.\n      centerMultiply(other) {\n        var from, k, to;\n        for (to = k = 0; k <= 5; to = ++k) {\n          from = other.center[to];\n          this.newCenter[to] = this.center[from];\n        }\n        [this.center, this.newCenter] = [this.newCenter, this.center];\n        return this;\n      }\n\n      // Multiply this Cube with another Cube, restricted to corners.\n      cornerMultiply(other) {\n        var from, k, to;\n        for (to = k = 0; k <= 7; to = ++k) {\n          from = other.cp[to];\n          this.newCp[to] = this.cp[from];\n          this.newCo[to] = (this.co[from] + other.co[to]) % 3;\n        }\n        [this.cp, this.newCp] = [this.newCp, this.cp];\n        [this.co, this.newCo] = [this.newCo, this.co];\n        return this;\n      }\n\n      // Multiply this Cube with another Cube, restricted to edges\n      edgeMultiply(other) {\n        var from, k, to;\n        for (to = k = 0; k <= 11; to = ++k) {\n          from = other.ep[to];\n          this.newEp[to] = this.ep[from];\n          this.newEo[to] = (this.eo[from] + other.eo[to]) % 2;\n        }\n        [this.ep, this.newEp] = [this.newEp, this.ep];\n        [this.eo, this.newEo] = [this.newEo, this.eo];\n        return this;\n      }\n\n      // Multiply this cube with another Cube\n      multiply(other) {\n        this.centerMultiply(other);\n        this.cornerMultiply(other);\n        this.edgeMultiply(other);\n        return this;\n      }\n\n      move(arg) {\n        var face, k, l, len, move, power, ref, ref1, x;\n        ref = parseAlg(arg);\n        for (k = 0, len = ref.length; k < len; k++) {\n          move = ref[k];\n          face = move / 3 | 0;\n          power = move % 3;\n          for (x = l = 0, ref1 = power; (0 <= ref1 ? l <= ref1 : l >= ref1); x = 0 <= ref1 ? ++l : --l) {\n            this.multiply(Cube.moves[face]);\n          }\n        }\n        return this;\n      }\n\n      upright() {\n        var clone, i, j, k, l, result;\n        clone = this.clone();\n        result = [];\n        for (i = k = 0; k <= 5; i = ++k) {\n          if (clone.center[i] === F) {\n            break;\n          }\n        }\n        switch (i) {\n          case D:\n            result.push(\"x\");\n            break;\n          case U:\n            result.push(\"x'\");\n            break;\n          case B:\n            result.push(\"x2\");\n            break;\n          case R:\n            result.push(\"y\");\n            break;\n          case L:\n            result.push(\"y'\");\n        }\n        if (result.length) {\n          clone.move(result[0]);\n        }\n        for (j = l = 0; l <= 5; j = ++l) {\n          if (clone.center[j] === U) {\n            break;\n          }\n        }\n        switch (j) {\n          case L:\n            result.push(\"z\");\n            break;\n          case R:\n            result.push(\"z'\");\n            break;\n          case D:\n            result.push(\"z2\");\n        }\n        return result.join(' ');\n      }\n\n      static inverse(arg) {\n        var face, k, len, move, power, result, str;\n        result = (function() {\n          var k, len, ref, results;\n          ref = parseAlg(arg);\n          results = [];\n          for (k = 0, len = ref.length; k < len; k++) {\n            move = ref[k];\n            face = move / 3 | 0;\n            power = move % 3;\n            results.push(face * 3 + -(power - 1) + 1);\n          }\n          return results;\n        })();\n        result.reverse();\n        if (typeof arg === 'string') {\n          str = '';\n          for (k = 0, len = result.length; k < len; k++) {\n            move = result[k];\n            face = move / 3 | 0;\n            power = move % 3;\n            str += faceNames[face];\n            if (power === 1) {\n              str += '2';\n            } else if (power === 2) {\n              str += \"'\";\n            }\n            str += ' ';\n          }\n          return str.substring(0, str.length - 1);\n        } else if (arg.length != null) {\n          return result;\n        } else {\n          return result[0];\n        }\n      }\n\n    };\n\n    Cube.prototype.randomize = (function() {\n      var arePermutationsValid, generateValidRandomOrientation, generateValidRandomPermutation, getNumSwaps, isOrientationValid, randint, randomizeOrientation, result, shuffle;\n      randint = function(min, max) {\n        return min + Math.floor(Math.random() * (max - min + 1));\n      };\n      // Fisher-Yates shuffle adapted from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n      shuffle = function(array) {\n        var currentIndex, randomIndex, temporaryValue;\n        currentIndex = array.length;\n        // While there remain elements to shuffle...\n        while (currentIndex !== 0) {\n          // Pick a remaining element...\n          randomIndex = randint(0, currentIndex - 1);\n          currentIndex -= 1;\n          // And swap it with the current element.\n          temporaryValue = array[currentIndex];\n          [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];\n        }\n      };\n      getNumSwaps = function(arr) {\n        var cur, cycleLength, i, k, numSwaps, ref, seen, x;\n        numSwaps = 0;\n        seen = (function() {\n          var k, ref, results;\n          results = [];\n          for (x = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); x = 0 <= ref ? ++k : --k) {\n            results.push(false);\n          }\n          return results;\n        })();\n        while (true) {\n          // We compute the cycle decomposition\n          cur = -1;\n          for (i = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); i = 0 <= ref ? ++k : --k) {\n            if (!seen[i]) {\n              cur = i;\n              break;\n            }\n          }\n          if (cur === -1) {\n            break;\n          }\n          cycleLength = 0;\n          while (!seen[cur]) {\n            seen[cur] = true;\n            cycleLength++;\n            cur = arr[cur];\n          }\n          // A cycle is equivalent to cycleLength + 1 swaps\n          numSwaps += cycleLength + 1;\n        }\n        return numSwaps;\n      };\n      arePermutationsValid = function(cp, ep) {\n        var numSwaps;\n        numSwaps = getNumSwaps(ep) + getNumSwaps(cp);\n        return numSwaps % 2 === 0;\n      };\n      generateValidRandomPermutation = function(cp, ep) {\n        // Each shuffle only takes around 12 operations and there's a 50%\n        // chance of a valid permutation so it'll finish in very good time\n        shuffle(ep);\n        shuffle(cp);\n        while (!arePermutationsValid(cp, ep)) {\n          shuffle(ep);\n          shuffle(cp);\n        }\n      };\n      randomizeOrientation = function(arr, numOrientations) {\n        var i, k, ori, ref;\n        ori = 0;\n        for (i = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); i = 0 <= ref ? ++k : --k) {\n          ori += (arr[i] = randint(0, numOrientations - 1));\n        }\n      };\n      isOrientationValid = function(arr, numOrientations) {\n        return arr.reduce(function(a, b) {\n          return a + b;\n        }) % numOrientations === 0;\n      };\n      generateValidRandomOrientation = function(co, eo) {\n        // There is a 1/2 and 1/3 probably respectively of each of these\n        // succeeding so the probability of them running 10 times before\n        // success is already only 1% and only gets exponentially lower\n        // and each generation is only in the 10s of operations which is nothing\n        randomizeOrientation(co, 3);\n        while (!isOrientationValid(co, 3)) {\n          randomizeOrientation(co, 3);\n        }\n        randomizeOrientation(eo, 2);\n        while (!isOrientationValid(eo, 2)) {\n          randomizeOrientation(eo, 2);\n        }\n      };\n      result = function() {\n        generateValidRandomPermutation(this.cp, this.ep);\n        generateValidRandomOrientation(this.co, this.eo);\n        return this;\n      };\n      return result;\n    })();\n\n    Cube.moves = [\n      {\n        // U\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [UBR,\n      URF,\n      UFL,\n      ULB,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UB,\n      UR,\n      UF,\n      UL,\n      DR,\n      DF,\n      DL,\n      DB,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // R\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [DFR,\n      UFL,\n      ULB,\n      URF,\n      DRB,\n      DLF,\n      DBL,\n      UBR],\n        co: [2,\n      0,\n      0,\n      1,\n      1,\n      0,\n      0,\n      2],\n        ep: [FR,\n      UF,\n      UL,\n      UB,\n      BR,\n      DF,\n      DL,\n      DB,\n      DR,\n      FL,\n      BL,\n      UR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // F\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [UFL,\n      DLF,\n      ULB,\n      UBR,\n      URF,\n      DFR,\n      DBL,\n      DRB],\n        co: [1,\n      2,\n      0,\n      0,\n      2,\n      1,\n      0,\n      0],\n        ep: [UR,\n      FL,\n      UL,\n      UB,\n      DR,\n      FR,\n      DL,\n      DB,\n      UF,\n      DF,\n      BL,\n      BR],\n        eo: [0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      1,\n      1,\n      0,\n      0]\n      },\n      {\n        // D\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DLF,\n      DBL,\n      DRB,\n      DFR],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UR,\n      UF,\n      UL,\n      UB,\n      DF,\n      DL,\n      DB,\n      DR,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // L\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [URF,\n      ULB,\n      DBL,\n      UBR,\n      DFR,\n      UFL,\n      DLF,\n      DRB],\n        co: [0,\n      1,\n      2,\n      0,\n      0,\n      2,\n      1,\n      0],\n        ep: [UR,\n      UF,\n      BL,\n      UB,\n      DR,\n      DF,\n      FL,\n      DB,\n      FR,\n      UL,\n      DL,\n      BR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // B\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [URF,\n      UFL,\n      UBR,\n      DRB,\n      DFR,\n      DLF,\n      ULB,\n      DBL],\n        co: [0,\n      0,\n      1,\n      2,\n      0,\n      0,\n      2,\n      1],\n        ep: [UR,\n      UF,\n      UL,\n      BR,\n      DR,\n      DF,\n      DL,\n      BL,\n      FR,\n      FL,\n      UB,\n      DB],\n        eo: [0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      1,\n      1]\n      },\n      {\n        // E\n        center: [U,\n      F,\n      L,\n      D,\n      B,\n      R],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UR,\n      UF,\n      UL,\n      UB,\n      DR,\n      DF,\n      DL,\n      DB,\n      FL,\n      BL,\n      BR,\n      FR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      1,\n      1,\n      1]\n      },\n      {\n        // M\n        center: [B,\n      R,\n      U,\n      F,\n      L,\n      D],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UR,\n      UB,\n      UL,\n      DB,\n      DR,\n      UF,\n      DL,\n      DF,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [0,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // S\n        center: [L,\n      U,\n      F,\n      R,\n      D,\n      B],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UL,\n      UF,\n      DL,\n      UB,\n      UR,\n      DF,\n      DR,\n      DB,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0]\n      }\n    ];\n\n    faceNums = {\n      U: 0,\n      R: 1,\n      F: 2,\n      D: 3,\n      L: 4,\n      B: 5,\n      E: 6,\n      M: 7,\n      S: 8,\n      x: 9,\n      y: 10,\n      z: 11,\n      u: 12,\n      r: 13,\n      f: 14,\n      d: 15,\n      l: 16,\n      b: 17\n    };\n\n    faceNames = {\n      0: 'U',\n      1: 'R',\n      2: 'F',\n      3: 'D',\n      4: 'L',\n      5: 'B',\n      6: 'E',\n      7: 'M',\n      8: 'S',\n      9: 'x',\n      10: 'y',\n      11: 'z',\n      12: 'u',\n      13: 'r',\n      14: 'f',\n      15: 'd',\n      16: 'l',\n      17: 'b'\n    };\n\n    parseAlg = function(arg) {\n      var k, len, move, part, power, ref, results;\n      if (typeof arg === 'string') {\n        ref = arg.split(/\\s+/);\n        // String\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          if (part.length === 0) {\n            // First and last can be empty\n            continue;\n          }\n          if (part.length > 2) {\n            throw new Error(`Invalid move: ${part}`);\n          }\n          move = faceNums[part[0]];\n          if (move === void 0) {\n            throw new Error(`Invalid move: ${part}`);\n          }\n          if (part.length === 1) {\n            power = 0;\n          } else {\n            if (part[1] === '2') {\n              power = 1;\n            } else if (part[1] === \"'\") {\n              power = 2;\n            } else {\n              throw new Error(`Invalid move: ${part}`);\n            }\n          }\n          results.push(move * 3 + power);\n        }\n        return results;\n      } else if (arg.length != null) {\n        // Already an array\n        return arg;\n      } else {\n        // A single move\n        return [arg];\n      }\n    };\n\n    // x\n    Cube.moves.push(new Cube().move(\"R M' L'\").toJSON());\n\n    // y\n    Cube.moves.push(new Cube().move(\"U E' D'\").toJSON());\n\n    // z\n    Cube.moves.push(new Cube().move(\"F S B'\").toJSON());\n\n    // u\n    Cube.moves.push(new Cube().move(\"U E'\").toJSON());\n\n    // r\n    Cube.moves.push(new Cube().move(\"R M'\").toJSON());\n\n    // f\n    Cube.moves.push(new Cube().move(\"F S\").toJSON());\n\n    // d\n    Cube.moves.push(new Cube().move(\"D E\").toJSON());\n\n    // l\n    Cube.moves.push(new Cube().move(\"L M\").toJSON());\n\n    // b\n    Cube.moves.push(new Cube().move(\"B S'\").toJSON());\n\n    return Cube;\n\n  }).call(this);\n\n  //# Globals\n  if ( true && module !== null) {\n    module.exports = Cube;\n  } else {\n    this.Cube = Cube;\n  }\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQ0FBa0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQ0FBa0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZCwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBLE1BQU0sS0FBNkI7QUFDbkM7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvbWluYXJpemsvRG93bmxvYWRzL3J1YmlrbmV4dC9ub2RlX21vZHVsZXMvY3ViZWpzL2xpYi9jdWJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpIHtcbiAgLy8gQ2VudGVyc1xuICB2YXIgQiwgQkwsIEJSLCBDdWJlLCBELCBEQiwgREJMLCBERiwgREZSLCBETCwgRExGLCBEUiwgRFJCLCBGLCBGTCwgRlIsIEwsIFIsIFUsIFVCLCBVQlIsIFVGLCBVRkwsIFVMLCBVTEIsIFVSLCBVUkYsIGNlbnRlckNvbG9yLCBjZW50ZXJGYWNlbGV0LCBjb3JuZXJDb2xvciwgY29ybmVyRmFjZWxldCwgZWRnZUNvbG9yLCBlZGdlRmFjZWxldDtcblxuICBbVSwgUiwgRiwgRCwgTCwgQl0gPSBbMCwgMSwgMiwgMywgNCwgNV07XG5cbiAgLy8gQ29ybmVyc1xuICBbVVJGLCBVRkwsIFVMQiwgVUJSLCBERlIsIERMRiwgREJMLCBEUkJdID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDddO1xuXG4gIC8vIEVkZ2VzXG4gIFtVUiwgVUYsIFVMLCBVQiwgRFIsIERGLCBETCwgREIsIEZSLCBGTCwgQkwsIEJSXSA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTFdO1xuXG4gIFtjZW50ZXJGYWNlbGV0LCBjb3JuZXJGYWNlbGV0LCBlZGdlRmFjZWxldF0gPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9CLCBfRCwgX0YsIF9MLCBfUiwgX1U7XG4gICAgX1UgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCAtIDE7XG4gICAgfTtcbiAgICBfUiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBfVSg5KSArIHg7XG4gICAgfTtcbiAgICBfRiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBfUig5KSArIHg7XG4gICAgfTtcbiAgICBfRCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBfRig5KSArIHg7XG4gICAgfTtcbiAgICBfTCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBfRCg5KSArIHg7XG4gICAgfTtcbiAgICBfQiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBfTCg5KSArIHg7XG4gICAgfTtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gQ2VudGVyc1xuICAgICAgWzQsXG4gICAgICAxMyxcbiAgICAgIDIyLFxuICAgICAgMzEsXG4gICAgICA0MCxcbiAgICAgIDQ5XSxcbiAgICAgIC8vIENvcm5lcnNcbiAgICAgIFtbX1UoOSksXG4gICAgICBfUigxKSxcbiAgICAgIF9GKDMpXSxcbiAgICAgIFtfVSg3KSxcbiAgICAgIF9GKDEpLFxuICAgICAgX0woMyldLFxuICAgICAgW19VKDEpLFxuICAgICAgX0woMSksXG4gICAgICBfQigzKV0sXG4gICAgICBbX1UoMyksXG4gICAgICBfQigxKSxcbiAgICAgIF9SKDMpXSxcbiAgICAgIFtfRCgzKSxcbiAgICAgIF9GKDkpLFxuICAgICAgX1IoNyldLFxuICAgICAgW19EKDEpLFxuICAgICAgX0woOSksXG4gICAgICBfRig3KV0sXG4gICAgICBbX0QoNyksXG4gICAgICBfQig5KSxcbiAgICAgIF9MKDcpXSxcbiAgICAgIFtfRCg5KSxcbiAgICAgIF9SKDkpLFxuICAgICAgX0IoNyldXSxcbiAgICAgIC8vIEVkZ2VzXG4gICAgICBbW19VKDYpLFxuICAgICAgX1IoMildLFxuICAgICAgW19VKDgpLFxuICAgICAgX0YoMildLFxuICAgICAgW19VKDQpLFxuICAgICAgX0woMildLFxuICAgICAgW19VKDIpLFxuICAgICAgX0IoMildLFxuICAgICAgW19EKDYpLFxuICAgICAgX1IoOCldLFxuICAgICAgW19EKDIpLFxuICAgICAgX0YoOCldLFxuICAgICAgW19EKDQpLFxuICAgICAgX0woOCldLFxuICAgICAgW19EKDgpLFxuICAgICAgX0IoOCldLFxuICAgICAgW19GKDYpLFxuICAgICAgX1IoNCldLFxuICAgICAgW19GKDQpLFxuICAgICAgX0woNildLFxuICAgICAgW19CKDYpLFxuICAgICAgX0woNCldLFxuICAgICAgW19CKDQpLFxuICAgICAgX1IoNildXVxuICAgIF07XG4gIH0pKCk7XG5cbiAgY2VudGVyQ29sb3IgPSBbJ1UnLCAnUicsICdGJywgJ0QnLCAnTCcsICdCJ107XG5cbiAgY29ybmVyQ29sb3IgPSBbWydVJywgJ1InLCAnRiddLCBbJ1UnLCAnRicsICdMJ10sIFsnVScsICdMJywgJ0InXSwgWydVJywgJ0InLCAnUiddLCBbJ0QnLCAnRicsICdSJ10sIFsnRCcsICdMJywgJ0YnXSwgWydEJywgJ0InLCAnTCddLCBbJ0QnLCAnUicsICdCJ11dO1xuXG4gIGVkZ2VDb2xvciA9IFtbJ1UnLCAnUiddLCBbJ1UnLCAnRiddLCBbJ1UnLCAnTCddLCBbJ1UnLCAnQiddLCBbJ0QnLCAnUiddLCBbJ0QnLCAnRiddLCBbJ0QnLCAnTCddLCBbJ0QnLCAnQiddLCBbJ0YnLCAnUiddLCBbJ0YnLCAnTCddLCBbJ0InLCAnTCddLCBbJ0InLCAnUiddXTtcblxuICBDdWJlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBmYWNlTmFtZXMsIGZhY2VOdW1zLCBwYXJzZUFsZztcblxuICAgIGNsYXNzIEN1YmUge1xuICAgICAgY29uc3RydWN0b3Iob3RoZXIpIHtcbiAgICAgICAgdmFyIHg7XG4gICAgICAgIGlmIChvdGhlciAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5pbml0KG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlkZW50aXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIG1vdmVzIHRvIGF2b2lkIGFsbG9jYXRpbmcgbmV3IG9iamVjdHMgZWFjaCB0aW1lXG4gICAgICAgIHRoaXMubmV3Q2VudGVyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBrLCByZXN1bHRzO1xuICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHggPSBrID0gMDsgayA8PSA1OyB4ID0gKytrKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICB0aGlzLm5ld0NwID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBrLCByZXN1bHRzO1xuICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHggPSBrID0gMDsgayA8PSA3OyB4ID0gKytrKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICB0aGlzLm5ld0VwID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBrLCByZXN1bHRzO1xuICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHggPSBrID0gMDsgayA8PSAxMTsgeCA9ICsraykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGhpcy5uZXdDbyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaywgcmVzdWx0cztcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yICh4ID0gayA9IDA7IGsgPD0gNzsgeCA9ICsraykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGhpcy5uZXdFbyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaywgcmVzdWx0cztcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yICh4ID0gayA9IDA7IGsgPD0gMTE7IHggPSArK2spIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIGluaXQoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBzdGF0ZS5jZW50ZXIuc2xpY2UoMCk7XG4gICAgICAgIHRoaXMuY28gPSBzdGF0ZS5jby5zbGljZSgwKTtcbiAgICAgICAgdGhpcy5lcCA9IHN0YXRlLmVwLnNsaWNlKDApO1xuICAgICAgICB0aGlzLmNwID0gc3RhdGUuY3Auc2xpY2UoMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVvID0gc3RhdGUuZW8uc2xpY2UoMCk7XG4gICAgICB9XG5cbiAgICAgIGlkZW50aXR5KCkge1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byB0aGUgaWRlbnRpdHkgY3ViZVxuICAgICAgICB0aGlzLmNlbnRlciA9IFswLCAxLCAyLCAzLCA0LCA1XTtcbiAgICAgICAgdGhpcy5jcCA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3XTtcbiAgICAgICAgdGhpcy5jbyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaywgcmVzdWx0cztcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yICh4ID0gayA9IDA7IGsgPD0gNzsgeCA9ICsraykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGhpcy5lcCA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTFdO1xuICAgICAgICByZXR1cm4gdGhpcy5lbyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaywgcmVzdWx0cztcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yICh4ID0gayA9IDA7IGsgPD0gMTE7IHggPSArK2spIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjZW50ZXI6IHRoaXMuY2VudGVyLFxuICAgICAgICAgIGNwOiB0aGlzLmNwLFxuICAgICAgICAgIGNvOiB0aGlzLmNvLFxuICAgICAgICAgIGVwOiB0aGlzLmVwLFxuICAgICAgICAgIGVvOiB0aGlzLmVvXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGFzU3RyaW5nKCkge1xuICAgICAgICB2YXIgY29ybmVyLCBlZGdlLCBpLCBrLCBsLCBtLCBuLCBvLCBvcmksIHAsIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwOyBrIDw9IDU7IGkgPSArK2spIHtcbiAgICAgICAgICByZXN1bHRbOSAqIGkgKyA0XSA9IGNlbnRlckNvbG9yW3RoaXMuY2VudGVyW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBsID0gMDsgbCA8PSA3OyBpID0gKytsKSB7XG4gICAgICAgICAgY29ybmVyID0gdGhpcy5jcFtpXTtcbiAgICAgICAgICBvcmkgPSB0aGlzLmNvW2ldO1xuICAgICAgICAgIGZvciAobiA9IG0gPSAwOyBtIDw9IDI7IG4gPSArK20pIHtcbiAgICAgICAgICAgIHJlc3VsdFtjb3JuZXJGYWNlbGV0W2ldWyhuICsgb3JpKSAlIDNdXSA9IGNvcm5lckNvbG9yW2Nvcm5lcl1bbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IG8gPSAwOyBvIDw9IDExOyBpID0gKytvKSB7XG4gICAgICAgICAgZWRnZSA9IHRoaXMuZXBbaV07XG4gICAgICAgICAgb3JpID0gdGhpcy5lb1tpXTtcbiAgICAgICAgICBmb3IgKG4gPSBwID0gMDsgcCA8PSAxOyBuID0gKytwKSB7XG4gICAgICAgICAgICByZXN1bHRbZWRnZUZhY2VsZXRbaV1bKG4gKyBvcmkpICUgMl1dID0gZWRnZUNvbG9yW2VkZ2VdW25dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIGNvbDEsIGNvbDIsIGN1YmUsIGksIGosIGssIGwsIG0sIG8sIG9yaSwgcCwgcSwgciwgcmVmO1xuICAgICAgICBjdWJlID0gbmV3IEN1YmU7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwOyBrIDw9IDU7IGkgPSArK2spIHtcbiAgICAgICAgICBmb3IgKGogPSBsID0gMDsgbCA8PSA1OyBqID0gKytsKSB7XG4gICAgICAgICAgICBpZiAoc3RyWzkgKiBpICsgNF0gPT09IGNlbnRlckNvbG9yW2pdKSB7XG4gICAgICAgICAgICAgIGN1YmUuY2VudGVyW2ldID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gbSA9IDA7IG0gPD0gNzsgaSA9ICsrbSkge1xuICAgICAgICAgIGZvciAob3JpID0gbyA9IDA7IG8gPD0gMjsgb3JpID0gKytvKSB7XG4gICAgICAgICAgICBpZiAoKHJlZiA9IHN0cltjb3JuZXJGYWNlbGV0W2ldW29yaV1dKSA9PT0gJ1UnIHx8IHJlZiA9PT0gJ0QnKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb2wxID0gc3RyW2Nvcm5lckZhY2VsZXRbaV1bKG9yaSArIDEpICUgM11dO1xuICAgICAgICAgIGNvbDIgPSBzdHJbY29ybmVyRmFjZWxldFtpXVsob3JpICsgMikgJSAzXV07XG4gICAgICAgICAgZm9yIChqID0gcCA9IDA7IHAgPD0gNzsgaiA9ICsrcCkge1xuICAgICAgICAgICAgaWYgKGNvbDEgPT09IGNvcm5lckNvbG9yW2pdWzFdICYmIGNvbDIgPT09IGNvcm5lckNvbG9yW2pdWzJdKSB7XG4gICAgICAgICAgICAgIGN1YmUuY3BbaV0gPSBqO1xuICAgICAgICAgICAgICBjdWJlLmNvW2ldID0gb3JpICUgMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gcSA9IDA7IHEgPD0gMTE7IGkgPSArK3EpIHtcbiAgICAgICAgICBmb3IgKGogPSByID0gMDsgciA8PSAxMTsgaiA9ICsrcikge1xuICAgICAgICAgICAgaWYgKHN0cltlZGdlRmFjZWxldFtpXVswXV0gPT09IGVkZ2VDb2xvcltqXVswXSAmJiBzdHJbZWRnZUZhY2VsZXRbaV1bMV1dID09PSBlZGdlQ29sb3Jbal1bMV0pIHtcbiAgICAgICAgICAgICAgY3ViZS5lcFtpXSA9IGo7XG4gICAgICAgICAgICAgIGN1YmUuZW9baV0gPSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJbZWRnZUZhY2VsZXRbaV1bMF1dID09PSBlZGdlQ29sb3Jbal1bMV0gJiYgc3RyW2VkZ2VGYWNlbGV0W2ldWzFdXSA9PT0gZWRnZUNvbG9yW2pdWzBdKSB7XG4gICAgICAgICAgICAgIGN1YmUuZXBbaV0gPSBqO1xuICAgICAgICAgICAgICBjdWJlLmVvW2ldID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdWJlO1xuICAgICAgfVxuXG4gICAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdWJlKHRoaXMudG9KU09OKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBBIGNsYXNzIG1ldGhvZCByZXR1cm5pbmcgYSBuZXcgcmFuZG9tIGN1YmVcbiAgICAgIHN0YXRpYyByYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ3ViZSgpLnJhbmRvbWl6ZSgpO1xuICAgICAgfVxuXG4gICAgICBpc1NvbHZlZCgpIHtcbiAgICAgICAgdmFyIGMsIGNlbnQsIGNsb25lLCBlLCBrLCBsLCBtO1xuICAgICAgICBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgY2xvbmUubW92ZShjbG9uZS51cHJpZ2h0KCkpO1xuICAgICAgICBmb3IgKGNlbnQgPSBrID0gMDsgayA8PSA1OyBjZW50ID0gKytrKSB7XG4gICAgICAgICAgaWYgKGNsb25lLmNlbnRlcltjZW50XSAhPT0gY2VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGMgPSBsID0gMDsgbCA8PSA3OyBjID0gKytsKSB7XG4gICAgICAgICAgaWYgKGNsb25lLmNwW2NdICE9PSBjKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjbG9uZS5jb1tjXSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGUgPSBtID0gMDsgbSA8PSAxMTsgZSA9ICsrbSkge1xuICAgICAgICAgIGlmIChjbG9uZS5lcFtlXSAhPT0gZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2xvbmUuZW9bZV0gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE11bHRpcGx5IHRoaXMgQ3ViZSB3aXRoIGFub3RoZXIgQ3ViZSwgcmVzdHJpY3RlZCB0byBjZW50ZXJzLlxuICAgICAgY2VudGVyTXVsdGlwbHkob3RoZXIpIHtcbiAgICAgICAgdmFyIGZyb20sIGssIHRvO1xuICAgICAgICBmb3IgKHRvID0gayA9IDA7IGsgPD0gNTsgdG8gPSArK2spIHtcbiAgICAgICAgICBmcm9tID0gb3RoZXIuY2VudGVyW3RvXTtcbiAgICAgICAgICB0aGlzLm5ld0NlbnRlclt0b10gPSB0aGlzLmNlbnRlcltmcm9tXTtcbiAgICAgICAgfVxuICAgICAgICBbdGhpcy5jZW50ZXIsIHRoaXMubmV3Q2VudGVyXSA9IFt0aGlzLm5ld0NlbnRlciwgdGhpcy5jZW50ZXJdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gTXVsdGlwbHkgdGhpcyBDdWJlIHdpdGggYW5vdGhlciBDdWJlLCByZXN0cmljdGVkIHRvIGNvcm5lcnMuXG4gICAgICBjb3JuZXJNdWx0aXBseShvdGhlcikge1xuICAgICAgICB2YXIgZnJvbSwgaywgdG87XG4gICAgICAgIGZvciAodG8gPSBrID0gMDsgayA8PSA3OyB0byA9ICsraykge1xuICAgICAgICAgIGZyb20gPSBvdGhlci5jcFt0b107XG4gICAgICAgICAgdGhpcy5uZXdDcFt0b10gPSB0aGlzLmNwW2Zyb21dO1xuICAgICAgICAgIHRoaXMubmV3Q29bdG9dID0gKHRoaXMuY29bZnJvbV0gKyBvdGhlci5jb1t0b10pICUgMztcbiAgICAgICAgfVxuICAgICAgICBbdGhpcy5jcCwgdGhpcy5uZXdDcF0gPSBbdGhpcy5uZXdDcCwgdGhpcy5jcF07XG4gICAgICAgIFt0aGlzLmNvLCB0aGlzLm5ld0NvXSA9IFt0aGlzLm5ld0NvLCB0aGlzLmNvXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIE11bHRpcGx5IHRoaXMgQ3ViZSB3aXRoIGFub3RoZXIgQ3ViZSwgcmVzdHJpY3RlZCB0byBlZGdlc1xuICAgICAgZWRnZU11bHRpcGx5KG90aGVyKSB7XG4gICAgICAgIHZhciBmcm9tLCBrLCB0bztcbiAgICAgICAgZm9yICh0byA9IGsgPSAwOyBrIDw9IDExOyB0byA9ICsraykge1xuICAgICAgICAgIGZyb20gPSBvdGhlci5lcFt0b107XG4gICAgICAgICAgdGhpcy5uZXdFcFt0b10gPSB0aGlzLmVwW2Zyb21dO1xuICAgICAgICAgIHRoaXMubmV3RW9bdG9dID0gKHRoaXMuZW9bZnJvbV0gKyBvdGhlci5lb1t0b10pICUgMjtcbiAgICAgICAgfVxuICAgICAgICBbdGhpcy5lcCwgdGhpcy5uZXdFcF0gPSBbdGhpcy5uZXdFcCwgdGhpcy5lcF07XG4gICAgICAgIFt0aGlzLmVvLCB0aGlzLm5ld0VvXSA9IFt0aGlzLm5ld0VvLCB0aGlzLmVvXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIE11bHRpcGx5IHRoaXMgY3ViZSB3aXRoIGFub3RoZXIgQ3ViZVxuICAgICAgbXVsdGlwbHkob3RoZXIpIHtcbiAgICAgICAgdGhpcy5jZW50ZXJNdWx0aXBseShvdGhlcik7XG4gICAgICAgIHRoaXMuY29ybmVyTXVsdGlwbHkob3RoZXIpO1xuICAgICAgICB0aGlzLmVkZ2VNdWx0aXBseShvdGhlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBtb3ZlKGFyZykge1xuICAgICAgICB2YXIgZmFjZSwgaywgbCwgbGVuLCBtb3ZlLCBwb3dlciwgcmVmLCByZWYxLCB4O1xuICAgICAgICByZWYgPSBwYXJzZUFsZyhhcmcpO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICBtb3ZlID0gcmVmW2tdO1xuICAgICAgICAgIGZhY2UgPSBtb3ZlIC8gMyB8IDA7XG4gICAgICAgICAgcG93ZXIgPSBtb3ZlICUgMztcbiAgICAgICAgICBmb3IgKHggPSBsID0gMCwgcmVmMSA9IHBvd2VyOyAoMCA8PSByZWYxID8gbCA8PSByZWYxIDogbCA+PSByZWYxKTsgeCA9IDAgPD0gcmVmMSA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgdGhpcy5tdWx0aXBseShDdWJlLm1vdmVzW2ZhY2VdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHVwcmlnaHQoKSB7XG4gICAgICAgIHZhciBjbG9uZSwgaSwgaiwgaywgbCwgcmVzdWx0O1xuICAgICAgICBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwOyBrIDw9IDU7IGkgPSArK2spIHtcbiAgICAgICAgICBpZiAoY2xvbmUuY2VudGVyW2ldID09PSBGKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgY2FzZSBEOlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJ4XCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBVOlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJ4J1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgQjpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwieDJcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgICByZXN1bHQucHVzaChcInlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgICByZXN1bHQucHVzaChcInknXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgY2xvbmUubW92ZShyZXN1bHRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IGwgPSAwOyBsIDw9IDU7IGogPSArK2wpIHtcbiAgICAgICAgICBpZiAoY2xvbmUuY2VudGVyW2pdID09PSBVKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChqKSB7XG4gICAgICAgICAgY2FzZSBMOlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJ6XCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSOlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJ6J1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiejJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcgJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBpbnZlcnNlKGFyZykge1xuICAgICAgICB2YXIgZmFjZSwgaywgbGVuLCBtb3ZlLCBwb3dlciwgcmVzdWx0LCBzdHI7XG4gICAgICAgIHJlc3VsdCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaywgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgcmVmID0gcGFyc2VBbGcoYXJnKTtcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChrID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICBtb3ZlID0gcmVmW2tdO1xuICAgICAgICAgICAgZmFjZSA9IG1vdmUgLyAzIHwgMDtcbiAgICAgICAgICAgIHBvd2VyID0gbW92ZSAlIDM7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goZmFjZSAqIDMgKyAtKHBvd2VyIC0gMSkgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHN0ciA9ICcnO1xuICAgICAgICAgIGZvciAoayA9IDAsIGxlbiA9IHJlc3VsdC5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgbW92ZSA9IHJlc3VsdFtrXTtcbiAgICAgICAgICAgIGZhY2UgPSBtb3ZlIC8gMyB8IDA7XG4gICAgICAgICAgICBwb3dlciA9IG1vdmUgJSAzO1xuICAgICAgICAgICAgc3RyICs9IGZhY2VOYW1lc1tmYWNlXTtcbiAgICAgICAgICAgIGlmIChwb3dlciA9PT0gMSkge1xuICAgICAgICAgICAgICBzdHIgKz0gJzInO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3dlciA9PT0gMikge1xuICAgICAgICAgICAgICBzdHIgKz0gXCInXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgKz0gJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnLmxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgQ3ViZS5wcm90b3R5cGUucmFuZG9taXplID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZVBlcm11dGF0aW9uc1ZhbGlkLCBnZW5lcmF0ZVZhbGlkUmFuZG9tT3JpZW50YXRpb24sIGdlbmVyYXRlVmFsaWRSYW5kb21QZXJtdXRhdGlvbiwgZ2V0TnVtU3dhcHMsIGlzT3JpZW50YXRpb25WYWxpZCwgcmFuZGludCwgcmFuZG9taXplT3JpZW50YXRpb24sIHJlc3VsdCwgc2h1ZmZsZTtcbiAgICAgIHJhbmRpbnQgPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgICAgIH07XG4gICAgICAvLyBGaXNoZXItWWF0ZXMgc2h1ZmZsZSBhZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjQ1MDk1NC9ob3ctdG8tcmFuZG9taXplLXNodWZmbGUtYS1qYXZhc2NyaXB0LWFycmF5XG4gICAgICBzaHVmZmxlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCwgcmFuZG9tSW5kZXgsIHRlbXBvcmFyeVZhbHVlO1xuICAgICAgICBjdXJyZW50SW5kZXggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIC8vIFdoaWxlIHRoZXJlIHJlbWFpbiBlbGVtZW50cyB0byBzaHVmZmxlLi4uXG4gICAgICAgIHdoaWxlIChjdXJyZW50SW5kZXggIT09IDApIHtcbiAgICAgICAgICAvLyBQaWNrIGEgcmVtYWluaW5nIGVsZW1lbnQuLi5cbiAgICAgICAgICByYW5kb21JbmRleCA9IHJhbmRpbnQoMCwgY3VycmVudEluZGV4IC0gMSk7XG4gICAgICAgICAgY3VycmVudEluZGV4IC09IDE7XG4gICAgICAgICAgLy8gQW5kIHN3YXAgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgICAgICAgIHRlbXBvcmFyeVZhbHVlID0gYXJyYXlbY3VycmVudEluZGV4XTtcbiAgICAgICAgICBbYXJyYXlbY3VycmVudEluZGV4XSwgYXJyYXlbcmFuZG9tSW5kZXhdXSA9IFthcnJheVtyYW5kb21JbmRleF0sIGFycmF5W2N1cnJlbnRJbmRleF1dO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZ2V0TnVtU3dhcHMgPSBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgdmFyIGN1ciwgY3ljbGVMZW5ndGgsIGksIGssIG51bVN3YXBzLCByZWYsIHNlZW4sIHg7XG4gICAgICAgIG51bVN3YXBzID0gMDtcbiAgICAgICAgc2VlbiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaywgcmVmLCByZXN1bHRzO1xuICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHggPSBrID0gMCwgcmVmID0gYXJyLmxlbmd0aCAtIDE7ICgwIDw9IHJlZiA/IGsgPD0gcmVmIDogayA+PSByZWYpOyB4ID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIC8vIFdlIGNvbXB1dGUgdGhlIGN5Y2xlIGRlY29tcG9zaXRpb25cbiAgICAgICAgICBjdXIgPSAtMTtcbiAgICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmID0gYXJyLmxlbmd0aCAtIDE7ICgwIDw9IHJlZiA/IGsgPD0gcmVmIDogayA+PSByZWYpOyBpID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGlmICghc2VlbltpXSkge1xuICAgICAgICAgICAgICBjdXIgPSBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1ciA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjeWNsZUxlbmd0aCA9IDA7XG4gICAgICAgICAgd2hpbGUgKCFzZWVuW2N1cl0pIHtcbiAgICAgICAgICAgIHNlZW5bY3VyXSA9IHRydWU7XG4gICAgICAgICAgICBjeWNsZUxlbmd0aCsrO1xuICAgICAgICAgICAgY3VyID0gYXJyW2N1cl07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEEgY3ljbGUgaXMgZXF1aXZhbGVudCB0byBjeWNsZUxlbmd0aCArIDEgc3dhcHNcbiAgICAgICAgICBudW1Td2FwcyArPSBjeWNsZUxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVN3YXBzO1xuICAgICAgfTtcbiAgICAgIGFyZVBlcm11dGF0aW9uc1ZhbGlkID0gZnVuY3Rpb24oY3AsIGVwKSB7XG4gICAgICAgIHZhciBudW1Td2FwcztcbiAgICAgICAgbnVtU3dhcHMgPSBnZXROdW1Td2FwcyhlcCkgKyBnZXROdW1Td2FwcyhjcCk7XG4gICAgICAgIHJldHVybiBudW1Td2FwcyAlIDIgPT09IDA7XG4gICAgICB9O1xuICAgICAgZ2VuZXJhdGVWYWxpZFJhbmRvbVBlcm11dGF0aW9uID0gZnVuY3Rpb24oY3AsIGVwKSB7XG4gICAgICAgIC8vIEVhY2ggc2h1ZmZsZSBvbmx5IHRha2VzIGFyb3VuZCAxMiBvcGVyYXRpb25zIGFuZCB0aGVyZSdzIGEgNTAlXG4gICAgICAgIC8vIGNoYW5jZSBvZiBhIHZhbGlkIHBlcm11dGF0aW9uIHNvIGl0J2xsIGZpbmlzaCBpbiB2ZXJ5IGdvb2QgdGltZVxuICAgICAgICBzaHVmZmxlKGVwKTtcbiAgICAgICAgc2h1ZmZsZShjcCk7XG4gICAgICAgIHdoaWxlICghYXJlUGVybXV0YXRpb25zVmFsaWQoY3AsIGVwKSkge1xuICAgICAgICAgIHNodWZmbGUoZXApO1xuICAgICAgICAgIHNodWZmbGUoY3ApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmFuZG9taXplT3JpZW50YXRpb24gPSBmdW5jdGlvbihhcnIsIG51bU9yaWVudGF0aW9ucykge1xuICAgICAgICB2YXIgaSwgaywgb3JpLCByZWY7XG4gICAgICAgIG9yaSA9IDA7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSBhcnIubGVuZ3RoIC0gMTsgKDAgPD0gcmVmID8gayA8PSByZWYgOiBrID49IHJlZik7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgIG9yaSArPSAoYXJyW2ldID0gcmFuZGludCgwLCBudW1PcmllbnRhdGlvbnMgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpc09yaWVudGF0aW9uVmFsaWQgPSBmdW5jdGlvbihhcnIsIG51bU9yaWVudGF0aW9ucykge1xuICAgICAgICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgICB9KSAlIG51bU9yaWVudGF0aW9ucyA9PT0gMDtcbiAgICAgIH07XG4gICAgICBnZW5lcmF0ZVZhbGlkUmFuZG9tT3JpZW50YXRpb24gPSBmdW5jdGlvbihjbywgZW8pIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgYSAxLzIgYW5kIDEvMyBwcm9iYWJseSByZXNwZWN0aXZlbHkgb2YgZWFjaCBvZiB0aGVzZVxuICAgICAgICAvLyBzdWNjZWVkaW5nIHNvIHRoZSBwcm9iYWJpbGl0eSBvZiB0aGVtIHJ1bm5pbmcgMTAgdGltZXMgYmVmb3JlXG4gICAgICAgIC8vIHN1Y2Nlc3MgaXMgYWxyZWFkeSBvbmx5IDElIGFuZCBvbmx5IGdldHMgZXhwb25lbnRpYWxseSBsb3dlclxuICAgICAgICAvLyBhbmQgZWFjaCBnZW5lcmF0aW9uIGlzIG9ubHkgaW4gdGhlIDEwcyBvZiBvcGVyYXRpb25zIHdoaWNoIGlzIG5vdGhpbmdcbiAgICAgICAgcmFuZG9taXplT3JpZW50YXRpb24oY28sIDMpO1xuICAgICAgICB3aGlsZSAoIWlzT3JpZW50YXRpb25WYWxpZChjbywgMykpIHtcbiAgICAgICAgICByYW5kb21pemVPcmllbnRhdGlvbihjbywgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZG9taXplT3JpZW50YXRpb24oZW8sIDIpO1xuICAgICAgICB3aGlsZSAoIWlzT3JpZW50YXRpb25WYWxpZChlbywgMikpIHtcbiAgICAgICAgICByYW5kb21pemVPcmllbnRhdGlvbihlbywgMik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZ2VuZXJhdGVWYWxpZFJhbmRvbVBlcm11dGF0aW9uKHRoaXMuY3AsIHRoaXMuZXApO1xuICAgICAgICBnZW5lcmF0ZVZhbGlkUmFuZG9tT3JpZW50YXRpb24odGhpcy5jbywgdGhpcy5lbyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkoKTtcblxuICAgIEN1YmUubW92ZXMgPSBbXG4gICAgICB7XG4gICAgICAgIC8vIFVcbiAgICAgICAgY2VudGVyOiBbMCwgMSwgMiwgMywgNCwgNV0sXG4gICAgICAgIGNwOiBbVUJSLFxuICAgICAgVVJGLFxuICAgICAgVUZMLFxuICAgICAgVUxCLFxuICAgICAgREZSLFxuICAgICAgRExGLFxuICAgICAgREJMLFxuICAgICAgRFJCXSxcbiAgICAgICAgY286IFswLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMF0sXG4gICAgICAgIGVwOiBbVUIsXG4gICAgICBVUixcbiAgICAgIFVGLFxuICAgICAgVUwsXG4gICAgICBEUixcbiAgICAgIERGLFxuICAgICAgREwsXG4gICAgICBEQixcbiAgICAgIEZSLFxuICAgICAgRkwsXG4gICAgICBCTCxcbiAgICAgIEJSXSxcbiAgICAgICAgZW86IFswLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBSXG4gICAgICAgIGNlbnRlcjogWzAsIDEsIDIsIDMsIDQsIDVdLFxuICAgICAgICBjcDogW0RGUixcbiAgICAgIFVGTCxcbiAgICAgIFVMQixcbiAgICAgIFVSRixcbiAgICAgIERSQixcbiAgICAgIERMRixcbiAgICAgIERCTCxcbiAgICAgIFVCUl0sXG4gICAgICAgIGNvOiBbMixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDJdLFxuICAgICAgICBlcDogW0ZSLFxuICAgICAgVUYsXG4gICAgICBVTCxcbiAgICAgIFVCLFxuICAgICAgQlIsXG4gICAgICBERixcbiAgICAgIERMLFxuICAgICAgREIsXG4gICAgICBEUixcbiAgICAgIEZMLFxuICAgICAgQkwsXG4gICAgICBVUl0sXG4gICAgICAgIGVvOiBbMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gRlxuICAgICAgICBjZW50ZXI6IFswLCAxLCAyLCAzLCA0LCA1XSxcbiAgICAgICAgY3A6IFtVRkwsXG4gICAgICBETEYsXG4gICAgICBVTEIsXG4gICAgICBVQlIsXG4gICAgICBVUkYsXG4gICAgICBERlIsXG4gICAgICBEQkwsXG4gICAgICBEUkJdLFxuICAgICAgICBjbzogWzEsXG4gICAgICAyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAyLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwXSxcbiAgICAgICAgZXA6IFtVUixcbiAgICAgIEZMLFxuICAgICAgVUwsXG4gICAgICBVQixcbiAgICAgIERSLFxuICAgICAgRlIsXG4gICAgICBETCxcbiAgICAgIERCLFxuICAgICAgVUYsXG4gICAgICBERixcbiAgICAgIEJMLFxuICAgICAgQlJdLFxuICAgICAgICBlbzogWzAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIERcbiAgICAgICAgY2VudGVyOiBbMCwgMSwgMiwgMywgNCwgNV0sXG4gICAgICAgIGNwOiBbVVJGLFxuICAgICAgVUZMLFxuICAgICAgVUxCLFxuICAgICAgVUJSLFxuICAgICAgRExGLFxuICAgICAgREJMLFxuICAgICAgRFJCLFxuICAgICAgREZSXSxcbiAgICAgICAgY286IFswLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMF0sXG4gICAgICAgIGVwOiBbVVIsXG4gICAgICBVRixcbiAgICAgIFVMLFxuICAgICAgVUIsXG4gICAgICBERixcbiAgICAgIERMLFxuICAgICAgREIsXG4gICAgICBEUixcbiAgICAgIEZSLFxuICAgICAgRkwsXG4gICAgICBCTCxcbiAgICAgIEJSXSxcbiAgICAgICAgZW86IFswLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBMXG4gICAgICAgIGNlbnRlcjogWzAsIDEsIDIsIDMsIDQsIDVdLFxuICAgICAgICBjcDogW1VSRixcbiAgICAgIFVMQixcbiAgICAgIERCTCxcbiAgICAgIFVCUixcbiAgICAgIERGUixcbiAgICAgIFVGTCxcbiAgICAgIERMRixcbiAgICAgIERSQl0sXG4gICAgICAgIGNvOiBbMCxcbiAgICAgIDEsXG4gICAgICAyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAyLFxuICAgICAgMSxcbiAgICAgIDBdLFxuICAgICAgICBlcDogW1VSLFxuICAgICAgVUYsXG4gICAgICBCTCxcbiAgICAgIFVCLFxuICAgICAgRFIsXG4gICAgICBERixcbiAgICAgIEZMLFxuICAgICAgREIsXG4gICAgICBGUixcbiAgICAgIFVMLFxuICAgICAgREwsXG4gICAgICBCUl0sXG4gICAgICAgIGVvOiBbMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gQlxuICAgICAgICBjZW50ZXI6IFswLCAxLCAyLCAzLCA0LCA1XSxcbiAgICAgICAgY3A6IFtVUkYsXG4gICAgICBVRkwsXG4gICAgICBVQlIsXG4gICAgICBEUkIsXG4gICAgICBERlIsXG4gICAgICBETEYsXG4gICAgICBVTEIsXG4gICAgICBEQkxdLFxuICAgICAgICBjbzogWzAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDIsXG4gICAgICAxXSxcbiAgICAgICAgZXA6IFtVUixcbiAgICAgIFVGLFxuICAgICAgVUwsXG4gICAgICBCUixcbiAgICAgIERSLFxuICAgICAgREYsXG4gICAgICBETCxcbiAgICAgIEJMLFxuICAgICAgRlIsXG4gICAgICBGTCxcbiAgICAgIFVCLFxuICAgICAgREJdLFxuICAgICAgICBlbzogWzAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMV1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIEVcbiAgICAgICAgY2VudGVyOiBbVSxcbiAgICAgIEYsXG4gICAgICBMLFxuICAgICAgRCxcbiAgICAgIEIsXG4gICAgICBSXSxcbiAgICAgICAgY3A6IFtVUkYsXG4gICAgICBVRkwsXG4gICAgICBVTEIsXG4gICAgICBVQlIsXG4gICAgICBERlIsXG4gICAgICBETEYsXG4gICAgICBEQkwsXG4gICAgICBEUkJdLFxuICAgICAgICBjbzogWzAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwXSxcbiAgICAgICAgZXA6IFtVUixcbiAgICAgIFVGLFxuICAgICAgVUwsXG4gICAgICBVQixcbiAgICAgIERSLFxuICAgICAgREYsXG4gICAgICBETCxcbiAgICAgIERCLFxuICAgICAgRkwsXG4gICAgICBCTCxcbiAgICAgIEJSLFxuICAgICAgRlJdLFxuICAgICAgICBlbzogWzAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDEsXG4gICAgICAxLFxuICAgICAgMV1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIE1cbiAgICAgICAgY2VudGVyOiBbQixcbiAgICAgIFIsXG4gICAgICBVLFxuICAgICAgRixcbiAgICAgIEwsXG4gICAgICBEXSxcbiAgICAgICAgY3A6IFtVUkYsXG4gICAgICBVRkwsXG4gICAgICBVTEIsXG4gICAgICBVQlIsXG4gICAgICBERlIsXG4gICAgICBETEYsXG4gICAgICBEQkwsXG4gICAgICBEUkJdLFxuICAgICAgICBjbzogWzAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwXSxcbiAgICAgICAgZXA6IFtVUixcbiAgICAgIFVCLFxuICAgICAgVUwsXG4gICAgICBEQixcbiAgICAgIERSLFxuICAgICAgVUYsXG4gICAgICBETCxcbiAgICAgIERGLFxuICAgICAgRlIsXG4gICAgICBGTCxcbiAgICAgIEJMLFxuICAgICAgQlJdLFxuICAgICAgICBlbzogWzAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIFNcbiAgICAgICAgY2VudGVyOiBbTCxcbiAgICAgIFUsXG4gICAgICBGLFxuICAgICAgUixcbiAgICAgIEQsXG4gICAgICBCXSxcbiAgICAgICAgY3A6IFtVUkYsXG4gICAgICBVRkwsXG4gICAgICBVTEIsXG4gICAgICBVQlIsXG4gICAgICBERlIsXG4gICAgICBETEYsXG4gICAgICBEQkwsXG4gICAgICBEUkJdLFxuICAgICAgICBjbzogWzAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwXSxcbiAgICAgICAgZXA6IFtVTCxcbiAgICAgIFVGLFxuICAgICAgREwsXG4gICAgICBVQixcbiAgICAgIFVSLFxuICAgICAgREYsXG4gICAgICBEUixcbiAgICAgIERCLFxuICAgICAgRlIsXG4gICAgICBGTCxcbiAgICAgIEJMLFxuICAgICAgQlJdLFxuICAgICAgICBlbzogWzEsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMF1cbiAgICAgIH1cbiAgICBdO1xuXG4gICAgZmFjZU51bXMgPSB7XG4gICAgICBVOiAwLFxuICAgICAgUjogMSxcbiAgICAgIEY6IDIsXG4gICAgICBEOiAzLFxuICAgICAgTDogNCxcbiAgICAgIEI6IDUsXG4gICAgICBFOiA2LFxuICAgICAgTTogNyxcbiAgICAgIFM6IDgsXG4gICAgICB4OiA5LFxuICAgICAgeTogMTAsXG4gICAgICB6OiAxMSxcbiAgICAgIHU6IDEyLFxuICAgICAgcjogMTMsXG4gICAgICBmOiAxNCxcbiAgICAgIGQ6IDE1LFxuICAgICAgbDogMTYsXG4gICAgICBiOiAxN1xuICAgIH07XG5cbiAgICBmYWNlTmFtZXMgPSB7XG4gICAgICAwOiAnVScsXG4gICAgICAxOiAnUicsXG4gICAgICAyOiAnRicsXG4gICAgICAzOiAnRCcsXG4gICAgICA0OiAnTCcsXG4gICAgICA1OiAnQicsXG4gICAgICA2OiAnRScsXG4gICAgICA3OiAnTScsXG4gICAgICA4OiAnUycsXG4gICAgICA5OiAneCcsXG4gICAgICAxMDogJ3knLFxuICAgICAgMTE6ICd6JyxcbiAgICAgIDEyOiAndScsXG4gICAgICAxMzogJ3InLFxuICAgICAgMTQ6ICdmJyxcbiAgICAgIDE1OiAnZCcsXG4gICAgICAxNjogJ2wnLFxuICAgICAgMTc6ICdiJ1xuICAgIH07XG5cbiAgICBwYXJzZUFsZyA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgdmFyIGssIGxlbiwgbW92ZSwgcGFydCwgcG93ZXIsIHJlZiwgcmVzdWx0cztcbiAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICByZWYgPSBhcmcuc3BsaXQoL1xccysvKTtcbiAgICAgICAgLy8gU3RyaW5nXG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgcGFydCA9IHJlZltrXTtcbiAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGFuZCBsYXN0IGNhbiBiZSBlbXB0eVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb3ZlOiAke3BhcnR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vdmUgPSBmYWNlTnVtc1twYXJ0WzBdXTtcbiAgICAgICAgICBpZiAobW92ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW92ZTogJHtwYXJ0fWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHBvd2VyID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhcnRbMV0gPT09ICcyJykge1xuICAgICAgICAgICAgICBwb3dlciA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRbMV0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgIHBvd2VyID0gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb3ZlOiAke3BhcnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMucHVzaChtb3ZlICogMyArIHBvd2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0gZWxzZSBpZiAoYXJnLmxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgc2luZ2xlIG1vdmVcbiAgICAgICAgcmV0dXJuIFthcmddO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB4XG4gICAgQ3ViZS5tb3Zlcy5wdXNoKG5ldyBDdWJlKCkubW92ZShcIlIgTScgTCdcIikudG9KU09OKCkpO1xuXG4gICAgLy8geVxuICAgIEN1YmUubW92ZXMucHVzaChuZXcgQ3ViZSgpLm1vdmUoXCJVIEUnIEQnXCIpLnRvSlNPTigpKTtcblxuICAgIC8vIHpcbiAgICBDdWJlLm1vdmVzLnB1c2gobmV3IEN1YmUoKS5tb3ZlKFwiRiBTIEInXCIpLnRvSlNPTigpKTtcblxuICAgIC8vIHVcbiAgICBDdWJlLm1vdmVzLnB1c2gobmV3IEN1YmUoKS5tb3ZlKFwiVSBFJ1wiKS50b0pTT04oKSk7XG5cbiAgICAvLyByXG4gICAgQ3ViZS5tb3Zlcy5wdXNoKG5ldyBDdWJlKCkubW92ZShcIlIgTSdcIikudG9KU09OKCkpO1xuXG4gICAgLy8gZlxuICAgIEN1YmUubW92ZXMucHVzaChuZXcgQ3ViZSgpLm1vdmUoXCJGIFNcIikudG9KU09OKCkpO1xuXG4gICAgLy8gZFxuICAgIEN1YmUubW92ZXMucHVzaChuZXcgQ3ViZSgpLm1vdmUoXCJEIEVcIikudG9KU09OKCkpO1xuXG4gICAgLy8gbFxuICAgIEN1YmUubW92ZXMucHVzaChuZXcgQ3ViZSgpLm1vdmUoXCJMIE1cIikudG9KU09OKCkpO1xuXG4gICAgLy8gYlxuICAgIEN1YmUubW92ZXMucHVzaChuZXcgQ3ViZSgpLm1vdmUoXCJCIFMnXCIpLnRvSlNPTigpKTtcblxuICAgIHJldHVybiBDdWJlO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbiAgLy8jIEdsb2JhbHNcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlICE9PSBudWxsKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDdWJlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuQ3ViZSA9IEN1YmU7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cubejs/lib/cube.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cubejs/lib/solve.js":
/*!******************************************!*\
  !*** ./node_modules/cubejs/lib/solve.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("(function() {\n  var B, BL, BR, Cnk, Cube, D, DB, DBL, DF, DFR, DL, DLF, DR, DRB, F, FL, FR, Include, L, N_FLIP, N_FRtoBR, N_PARITY, N_SLICE1, N_SLICE2, N_TWIST, N_UBtoDF, N_URFtoDLF, N_URtoDF, N_URtoUL, R, U, UB, UBR, UF, UFL, UL, ULB, UR, URF, allMoves1, allMoves2, computeMoveTable, computePruningTable, faceNames, faceNums, factorial, key, max, mergeURtoDF, moveTableParams, nextMoves1, nextMoves2, permutationIndex, pruning, pruningTableParams, rotateLeft, rotateRight, value,\n    indexOf = [].indexOf;\n\n  Cube = this.Cube || __webpack_require__(/*! ./cube */ \"(ssr)/./node_modules/cubejs/lib/cube.js\");\n\n  // Centers\n  [U, R, F, D, L, B] = [0, 1, 2, 3, 4, 5];\n\n  // Corners\n  [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB] = [0, 1, 2, 3, 4, 5, 6, 7];\n\n  // Edges\n  [UR, UF, UL, UB, DR, DF, DL, DB, FR, FL, BL, BR] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\n  //# Helpers\n\n  // n choose k, i.e. the binomial coeffiecient\n  Cnk = function(n, k) {\n    var i, j, s;\n    if (n < k) {\n      return 0;\n    }\n    if (k > n / 2) {\n      k = n - k;\n    }\n    s = 1;\n    i = n;\n    j = 1;\n    while (i !== n - k) {\n      s *= i;\n      s /= j;\n      i--;\n      j++;\n    }\n    return s;\n  };\n\n  // n!\n  factorial = function(n) {\n    var f, i, m, ref;\n    f = 1;\n    for (i = m = 2, ref = n; (2 <= ref ? m <= ref : m >= ref); i = 2 <= ref ? ++m : --m) {\n      f *= i;\n    }\n    return f;\n  };\n\n  // Maximum of two values\n  max = function(a, b) {\n    if (a > b) {\n      return a;\n    } else {\n      return b;\n    }\n  };\n\n  // Rotate elements between l and r left by one place\n  rotateLeft = function(array, l, r) {\n    var i, m, ref, ref1, tmp;\n    tmp = array[l];\n    for (i = m = ref = l, ref1 = r - 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n      array[i] = array[i + 1];\n    }\n    return array[r] = tmp;\n  };\n\n  // Rotate elements between l and r right by one place\n  rotateRight = function(array, l, r) {\n    var i, m, ref, ref1, tmp;\n    tmp = array[r];\n    for (i = m = ref = r, ref1 = l + 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n      array[i] = array[i - 1];\n    }\n    return array[l] = tmp;\n  };\n\n  // Generate a function that computes permutation indices.\n\n  // The permutation index actually encodes two indices: Combination,\n  // i.e. positions of the cubies start..end (A) and their respective\n  // permutation (B). The maximum value for B is\n\n  //   maxB = (end - start + 1)!\n\n  // and the index is A * maxB + B\n  permutationIndex = function(context, start, end, fromEnd = false) {\n    var i, maxAll, maxB, maxOur, our, permName;\n    maxOur = end - start;\n    maxB = factorial(maxOur + 1);\n    if (context === 'corners') {\n      maxAll = 7;\n      permName = 'cp';\n    } else {\n      maxAll = 11;\n      permName = 'ep';\n    }\n    our = (function() {\n      var m, ref, results;\n      results = [];\n      for (i = m = 0, ref = maxOur; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {\n        results.push(0);\n      }\n      return results;\n    })();\n    return function(index) {\n      var a, b, c, j, k, m, o, p, perm, q, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t, u, w, x, y, z;\n      if (index != null) {\n        for (i = m = 0, ref = maxOur; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {\n          // Reset our to [start..end]\n          our[i] = i + start;\n        }\n        b = index % maxB; // permutation\n        a = index / maxB | 0; // combination\n        \n        // Invalidate all edges\n        perm = this[permName];\n        for (i = o = 0, ref1 = maxAll; (0 <= ref1 ? o <= ref1 : o >= ref1); i = 0 <= ref1 ? ++o : --o) {\n          perm[i] = -1;\n        }\n// Generate permutation from index b\n        for (j = p = 1, ref2 = maxOur; (1 <= ref2 ? p <= ref2 : p >= ref2); j = 1 <= ref2 ? ++p : --p) {\n          k = b % (j + 1);\n          b = b / (j + 1) | 0;\n          // TODO: Implement rotateRightBy(our, 0, j, k)\n          while (k > 0) {\n            rotateRight(our, 0, j);\n            k--;\n          }\n        }\n        // Generate combination and set our edges\n        x = maxOur;\n        if (fromEnd) {\n          for (j = q = 0, ref3 = maxAll; (0 <= ref3 ? q <= ref3 : q >= ref3); j = 0 <= ref3 ? ++q : --q) {\n            c = Cnk(maxAll - j, x + 1);\n            if (a - c >= 0) {\n              perm[j] = our[maxOur - x];\n              a -= c;\n              x--;\n            }\n          }\n        } else {\n          for (j = t = ref4 = maxAll; (ref4 <= 0 ? t <= 0 : t >= 0); j = ref4 <= 0 ? ++t : --t) {\n            c = Cnk(j, x + 1);\n            if (a - c >= 0) {\n              perm[j] = our[x];\n              a -= c;\n              x--;\n            }\n          }\n        }\n        return this;\n      } else {\n        perm = this[permName];\n        for (i = u = 0, ref5 = maxOur; (0 <= ref5 ? u <= ref5 : u >= ref5); i = 0 <= ref5 ? ++u : --u) {\n          our[i] = -1;\n        }\n        a = b = x = 0;\n        // Compute the index a < ((maxAll + 1) choose (maxOur + 1)) and\n        // the permutation\n        if (fromEnd) {\n          for (j = w = ref6 = maxAll; (ref6 <= 0 ? w <= 0 : w >= 0); j = ref6 <= 0 ? ++w : --w) {\n            if ((start <= (ref7 = perm[j]) && ref7 <= end)) {\n              a += Cnk(maxAll - j, x + 1);\n              our[maxOur - x] = perm[j];\n              x++;\n            }\n          }\n        } else {\n          for (j = y = 0, ref8 = maxAll; (0 <= ref8 ? y <= ref8 : y >= ref8); j = 0 <= ref8 ? ++y : --y) {\n            if ((start <= (ref9 = perm[j]) && ref9 <= end)) {\n              a += Cnk(j, x + 1);\n              our[x] = perm[j];\n              x++;\n            }\n          }\n        }\n// Compute the index b < (maxOur + 1)! for the permutation\n        for (j = z = ref10 = maxOur; (ref10 <= 0 ? z <= 0 : z >= 0); j = ref10 <= 0 ? ++z : --z) {\n          k = 0;\n          while (our[j] !== start + j) {\n            rotateLeft(our, 0, j);\n            k++;\n          }\n          b = (j + 1) * b + k;\n        }\n        return a * maxB + b;\n      }\n    };\n  };\n\n  Include = {\n    // The twist of the 8 corners, 0 <= twist < 3^7. The orientation of\n    // the DRB corner is fully determined by the orientation of the other\n    // corners.\n    twist: function(twist) {\n      var i, m, o, ori, parity, v;\n      if (twist != null) {\n        parity = 0;\n        for (i = m = 6; m >= 0; i = --m) {\n          ori = twist % 3;\n          twist = (twist / 3) | 0;\n          this.co[i] = ori;\n          parity += ori;\n        }\n        this.co[7] = (3 - parity % 3) % 3;\n        return this;\n      } else {\n        v = 0;\n        for (i = o = 0; o <= 6; i = ++o) {\n          v = 3 * v + this.co[i];\n        }\n        return v;\n      }\n    },\n    // The flip of the 12 edges, 0 <= flip < 2^11. The orientation of the\n    // BR edge is fully determined by the orientation of the other edges.\n    flip: function(flip) {\n      var i, m, o, ori, parity, v;\n      if (flip != null) {\n        parity = 0;\n        for (i = m = 10; m >= 0; i = --m) {\n          ori = flip % 2;\n          flip = flip / 2 | 0;\n          this.eo[i] = ori;\n          parity += ori;\n        }\n        this.eo[11] = (2 - parity % 2) % 2;\n        return this;\n      } else {\n        v = 0;\n        for (i = o = 0; o <= 10; i = ++o) {\n          v = 2 * v + this.eo[i];\n        }\n        return v;\n      }\n    },\n    // Parity of the corner permutation\n    cornerParity: function() {\n      var i, j, m, o, ref, ref1, ref2, ref3, s;\n      s = 0;\n      for (i = m = ref = DRB, ref1 = URF + 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n        for (j = o = ref2 = i - 1, ref3 = URF; (ref2 <= ref3 ? o <= ref3 : o >= ref3); j = ref2 <= ref3 ? ++o : --o) {\n          if (this.cp[j] > this.cp[i]) {\n            s++;\n          }\n        }\n      }\n      return s % 2;\n    },\n    // Parity of the edges permutation. Parity of corners and edges are\n    // the same if the cube is solvable.\n    edgeParity: function() {\n      var i, j, m, o, ref, ref1, ref2, ref3, s;\n      s = 0;\n      for (i = m = ref = BR, ref1 = UR + 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n        for (j = o = ref2 = i - 1, ref3 = UR; (ref2 <= ref3 ? o <= ref3 : o >= ref3); j = ref2 <= ref3 ? ++o : --o) {\n          if (this.ep[j] > this.ep[i]) {\n            s++;\n          }\n        }\n      }\n      return s % 2;\n    },\n    // Permutation of the six corners URF, UFL, ULB, UBR, DFR, DLF\n    URFtoDLF: permutationIndex('corners', URF, DLF),\n    // Permutation of the three edges UR, UF, UL\n    URtoUL: permutationIndex('edges', UR, UL),\n    // Permutation of the three edges UB, DR, DF\n    UBtoDF: permutationIndex('edges', UB, DF),\n    // Permutation of the six edges UR, UF, UL, UB, DR, DF\n    URtoDF: permutationIndex('edges', UR, DF),\n    // Permutation of the equator slice edges FR, FL, BL and BR\n    FRtoBR: permutationIndex('edges', FR, BR, true)\n  };\n\n  for (key in Include) {\n    value = Include[key];\n    Cube.prototype[key] = value;\n  }\n\n  computeMoveTable = function(context, coord, size) {\n    var apply, cube, i, inner, j, k, m, move, o, p, ref, results;\n    // Loop through all valid values for the coordinate, setting cube's\n    // state in each iteration. Then apply each of the 18 moves to the\n    // cube, and compute the resulting coordinate.\n    apply = context === 'corners' ? 'cornerMultiply' : 'edgeMultiply';\n    cube = new Cube;\n    results = [];\n    for (i = m = 0, ref = size - 1; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {\n      cube[coord](i);\n      inner = [];\n      for (j = o = 0; o <= 5; j = ++o) {\n        move = Cube.moves[j];\n        for (k = p = 0; p <= 2; k = ++p) {\n          cube[apply](move);\n          inner.push(cube[coord]());\n        }\n        // 4th face turn restores the cube\n        cube[apply](move);\n      }\n      results.push(inner);\n    }\n    return results;\n  };\n\n  // Because we only have the phase 2 URtoDF coordinates, we need to\n  // merge the URtoUL and UBtoDF coordinates to URtoDF in the beginning\n  // of phase 2.\n  mergeURtoDF = (function() {\n    var a, b;\n    a = new Cube;\n    b = new Cube;\n    return function(URtoUL, UBtoDF) {\n      var i, m;\n      // Collisions can be found because unset are set to -1\n      a.URtoUL(URtoUL);\n      b.UBtoDF(UBtoDF);\n      for (i = m = 0; m <= 7; i = ++m) {\n        if (a.ep[i] !== -1) {\n          if (b.ep[i] !== -1) {\n            return -1; // collision\n          } else {\n            b.ep[i] = a.ep[i];\n          }\n        }\n      }\n      return b.URtoDF();\n    };\n  })();\n\n  N_TWIST = 2187; // 3^7 corner orientations\n\n  N_FLIP = 2048; // 2^11 possible edge flips\n\n  N_PARITY = 2; // 2 possible parities\n\n  N_FRtoBR = 11880; // 12!/(12-4)! permutations of FR..BR edges\n\n  N_SLICE1 = 495; // (12 choose 4) possible positions of FR..BR edges\n\n  N_SLICE2 = 24; // 4! permutations of FR..BR edges in phase 2\n\n  N_URFtoDLF = 20160; // 8!/(8-6)! permutations of URF..DLF corners\n\n  \n  // The URtoDF move table is only computed for phase 2 because the full\n  // table would have >650000 entries\n  N_URtoDF = 20160; // 8!/(8-6)! permutation of UR..DF edges in phase 2\n\n  N_URtoUL = 1320; // 12!/(12-3)! permutations of UR..UL edges\n\n  N_UBtoDF = 1320; // 12!/(12-3)! permutations of UB..DF edges\n\n  \n  // The move table for parity is so small that it's included here\n  Cube.moveTables = {\n    parity: [[1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]],\n    twist: null,\n    flip: null,\n    FRtoBR: null,\n    URFtoDLF: null,\n    URtoDF: null,\n    URtoUL: null,\n    UBtoDF: null,\n    mergeURtoDF: null\n  };\n\n  // Other move tables are computed on the fly\n  moveTableParams = {\n    // name: [scope, size]\n    twist: ['corners', N_TWIST],\n    flip: ['edges', N_FLIP],\n    FRtoBR: ['edges', N_FRtoBR],\n    URFtoDLF: ['corners', N_URFtoDLF],\n    URtoDF: ['edges', N_URtoDF],\n    URtoUL: ['edges', N_URtoUL],\n    UBtoDF: ['edges', N_UBtoDF],\n    mergeURtoDF: []\n  };\n\n  Cube.computeMoveTables = function(...tables) {\n    var len, m, name, scope, size, tableName;\n    if (tables.length === 0) {\n      tables = (function() {\n        var results;\n        results = [];\n        for (name in moveTableParams) {\n          results.push(name);\n        }\n        return results;\n      })();\n    }\n    for (m = 0, len = tables.length; m < len; m++) {\n      tableName = tables[m];\n      if (this.moveTables[tableName] !== null) {\n        // Already computed\n        continue;\n      }\n      if (tableName === 'mergeURtoDF') {\n        this.moveTables.mergeURtoDF = (function() {\n          var UBtoDF, URtoUL, o, results;\n          results = [];\n          for (URtoUL = o = 0; o <= 335; URtoUL = ++o) {\n            results.push((function() {\n              var p, results1;\n              results1 = [];\n              for (UBtoDF = p = 0; p <= 335; UBtoDF = ++p) {\n                results1.push(mergeURtoDF(URtoUL, UBtoDF));\n              }\n              return results1;\n            })());\n          }\n          return results;\n        })();\n      } else {\n        [scope, size] = moveTableParams[tableName];\n        this.moveTables[tableName] = computeMoveTable(scope, tableName, size);\n      }\n    }\n    return this;\n  };\n\n  // Phase 1: All moves are valid\n  allMoves1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17];\n\n  // The list of next valid phase 1 moves when the given face was turned\n  // in the last move\n  nextMoves1 = (function() {\n    var face, lastFace, m, next, o, p, power, results;\n    results = [];\n    for (lastFace = m = 0; m <= 5; lastFace = ++m) {\n      next = [];\n// Don't allow commuting moves, e.g. U U'. Also make sure that\n// opposite faces are always moved in the same order, i.e. allow\n// U D but no D U. This avoids sequences like U D U'.\n      for (face = o = 0; o <= 5; face = ++o) {\n        if (face !== lastFace && face !== lastFace - 3) {\n// single, double or inverse move\n          for (power = p = 0; p <= 2; power = ++p) {\n            next.push(face * 3 + power);\n          }\n        }\n      }\n      results.push(next);\n    }\n    return results;\n  })();\n\n  // Phase 2: Double moves of all faces plus quarter moves of U and D\n  allMoves2 = [0, 1, 2, 4, 7, 9, 10, 11, 13, 16];\n\n  nextMoves2 = (function() {\n    var face, lastFace, len, m, next, o, p, power, powers, results;\n    results = [];\n    for (lastFace = m = 0; m <= 5; lastFace = ++m) {\n      next = [];\n      for (face = o = 0; o <= 5; face = ++o) {\n        if (!(face !== lastFace && face !== lastFace - 3)) {\n          continue;\n        }\n        // Allow all moves of U and D and double moves of others\n        powers = face === 0 || face === 3 ? [0, 1, 2] : [1];\n        for (p = 0, len = powers.length; p < len; p++) {\n          power = powers[p];\n          next.push(face * 3 + power);\n        }\n      }\n      results.push(next);\n    }\n    return results;\n  })();\n\n  // 8 values are encoded in one number\n  pruning = function(table, index, value) {\n    var pos, shift, slot;\n    pos = index % 8;\n    slot = index >> 3;\n    shift = pos << 2;\n    if (value != null) {\n      // Set\n      table[slot] &= ~(0xF << shift);\n      table[slot] |= value << shift;\n      return value;\n    } else {\n      // Get\n      return (table[slot] & (0xF << shift)) >>> shift;\n    }\n  };\n\n  computePruningTable = function(phase, size, currentCoords, nextIndex) {\n    var current, depth, done, index, len, m, move, moves, next, o, ref, table, x;\n    // Initialize all values to 0xF\n    table = (function() {\n      var m, ref, results;\n      results = [];\n      for (x = m = 0, ref = Math.ceil(size / 8) - 1; (0 <= ref ? m <= ref : m >= ref); x = 0 <= ref ? ++m : --m) {\n        results.push(0xFFFFFFFF);\n      }\n      return results;\n    })();\n    if (phase === 1) {\n      moves = allMoves1;\n    } else {\n      moves = allMoves2;\n    }\n    depth = 0;\n    pruning(table, 0, depth);\n    done = 1;\n    // In each iteration, take each state found in the previous depth and\n    // compute the next state. Stop when all states have been assigned a\n    // depth.\n    while (done !== size) {\n      for (index = m = 0, ref = size - 1; (0 <= ref ? m <= ref : m >= ref); index = 0 <= ref ? ++m : --m) {\n        if (!(pruning(table, index) === depth)) {\n          continue;\n        }\n        current = currentCoords(index);\n        for (o = 0, len = moves.length; o < len; o++) {\n          move = moves[o];\n          next = nextIndex(current, move);\n          if (pruning(table, next) === 0xF) {\n            pruning(table, next, depth + 1);\n            done++;\n          }\n        }\n      }\n      depth++;\n    }\n    return table;\n  };\n\n  Cube.pruningTables = {\n    sliceTwist: null,\n    sliceFlip: null,\n    sliceURFtoDLFParity: null,\n    sliceURtoDFParity: null\n  };\n\n  pruningTableParams = {\n    // name: [phase, size, currentCoords, nextIndex]\n    sliceTwist: [\n      1,\n      N_SLICE1 * N_TWIST,\n      function(index) {\n        return [index % N_SLICE1,\n      index / N_SLICE1 | 0];\n      },\n      function(current,\n      move) {\n        var newSlice,\n      newTwist,\n      slice,\n      twist;\n        [slice,\n      twist] = current;\n        newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;\n        newTwist = Cube.moveTables.twist[twist][move];\n        return newTwist * N_SLICE1 + newSlice;\n      }\n    ],\n    sliceFlip: [\n      1,\n      N_SLICE1 * N_FLIP,\n      function(index) {\n        return [index % N_SLICE1,\n      index / N_SLICE1 | 0];\n      },\n      function(current,\n      move) {\n        var flip,\n      newFlip,\n      newSlice,\n      slice;\n        [slice,\n      flip] = current;\n        newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;\n        newFlip = Cube.moveTables.flip[flip][move];\n        return newFlip * N_SLICE1 + newSlice;\n      }\n    ],\n    sliceURFtoDLFParity: [\n      2,\n      N_SLICE2 * N_URFtoDLF * N_PARITY,\n      function(index) {\n        return [index % 2,\n      (index / 2 | 0) % N_SLICE2,\n      (index / 2 | 0) / N_SLICE2 | 0];\n      },\n      function(current,\n      move) {\n        var URFtoDLF,\n      newParity,\n      newSlice,\n      newURFtoDLF,\n      parity,\n      slice;\n        [parity,\n      slice,\n      URFtoDLF] = current;\n        newParity = Cube.moveTables.parity[parity][move];\n        newSlice = Cube.moveTables.FRtoBR[slice][move];\n        newURFtoDLF = Cube.moveTables.URFtoDLF[URFtoDLF][move];\n        return (newURFtoDLF * N_SLICE2 + newSlice) * 2 + newParity;\n      }\n    ],\n    sliceURtoDFParity: [\n      2,\n      N_SLICE2 * N_URtoDF * N_PARITY,\n      function(index) {\n        return [index % 2,\n      (index / 2 | 0) % N_SLICE2,\n      (index / 2 | 0) / N_SLICE2 | 0];\n      },\n      function(current,\n      move) {\n        var URtoDF,\n      newParity,\n      newSlice,\n      newURtoDF,\n      parity,\n      slice;\n        [parity,\n      slice,\n      URtoDF] = current;\n        newParity = Cube.moveTables.parity[parity][move];\n        newSlice = Cube.moveTables.FRtoBR[slice][move];\n        newURtoDF = Cube.moveTables.URtoDF[URtoDF][move];\n        return (newURtoDF * N_SLICE2 + newSlice) * 2 + newParity;\n      }\n    ]\n  };\n\n  Cube.computePruningTables = function(...tables) {\n    var len, m, name, params, tableName;\n    if (tables.length === 0) {\n      tables = (function() {\n        var results;\n        results = [];\n        for (name in pruningTableParams) {\n          results.push(name);\n        }\n        return results;\n      })();\n    }\n    for (m = 0, len = tables.length; m < len; m++) {\n      tableName = tables[m];\n      if (this.pruningTables[tableName] !== null) {\n        // Already computed\n        continue;\n      }\n      params = pruningTableParams[tableName];\n      this.pruningTables[tableName] = computePruningTable(...params);\n    }\n    return this;\n  };\n\n  Cube.initSolver = function() {\n    Cube.computeMoveTables();\n    return Cube.computePruningTables();\n  };\n\n  Cube.prototype.solveUpright = function(maxDepth = 22) {\n    var State, freeStates, moveNames, phase1, phase1search, phase2, phase2search, solution, state, x;\n    // Names for all moves, i.e. U, U2, U', F, F2, ...\n    moveNames = (function() {\n      var face, faceName, m, o, power, powerName, result;\n      faceName = ['U', 'R', 'F', 'D', 'L', 'B'];\n      powerName = ['', '2', \"'\"];\n      result = [];\n      for (face = m = 0; m <= 5; face = ++m) {\n        for (power = o = 0; o <= 2; power = ++o) {\n          result.push(faceName[face] + powerName[power]);\n        }\n      }\n      return result;\n    })();\n    State = class State {\n      constructor(cube) {\n        this.parent = null;\n        this.lastMove = null;\n        this.depth = 0;\n        if (cube) {\n          this.init(cube);\n        }\n      }\n\n      init(cube) {\n        // Phase 1 coordinates\n        this.flip = cube.flip();\n        this.twist = cube.twist();\n        this.slice = cube.FRtoBR() / N_SLICE2 | 0;\n        // Phase 2 coordinates\n        this.parity = cube.cornerParity();\n        this.URFtoDLF = cube.URFtoDLF();\n        this.FRtoBR = cube.FRtoBR();\n        // These are later merged to URtoDF when phase 2 begins\n        this.URtoUL = cube.URtoUL();\n        this.UBtoDF = cube.UBtoDF();\n        return this;\n      }\n\n      solution() {\n        if (this.parent) {\n          return this.parent.solution() + moveNames[this.lastMove] + ' ';\n        } else {\n          return '';\n        }\n      }\n\n      //# Helpers\n      move(table, index, move) {\n        return Cube.moveTables[table][index][move];\n      }\n\n      pruning(table, index) {\n        return pruning(Cube.pruningTables[table], index);\n      }\n\n      //# Phase 1\n\n      // Return the next valid phase 1 moves for this state\n      moves1() {\n        if (this.lastMove !== null) {\n          return nextMoves1[this.lastMove / 3 | 0];\n        } else {\n          return allMoves1;\n        }\n      }\n\n      // Compute the minimum number of moves to the end of phase 1\n      minDist1() {\n        var d1, d2;\n        // The maximum number of moves to the end of phase 1 wrt. the\n        // combination flip and slice coordinates only\n        d1 = this.pruning('sliceFlip', N_SLICE1 * this.flip + this.slice);\n        // The combination of twist and slice coordinates\n        d2 = this.pruning('sliceTwist', N_SLICE1 * this.twist + this.slice);\n        // The true minimal distance is the maximum of these two\n        return max(d1, d2);\n      }\n\n      // Compute the next phase 1 state for the given move\n      next1(move) {\n        var next;\n        next = freeStates.pop();\n        next.parent = this;\n        next.lastMove = move;\n        next.depth = this.depth + 1;\n        next.flip = this.move('flip', this.flip, move);\n        next.twist = this.move('twist', this.twist, move);\n        next.slice = this.move('FRtoBR', this.slice * 24, move) / 24 | 0;\n        return next;\n      }\n\n      //# Phase 2\n\n      // Return the next valid phase 2 moves for this state\n      moves2() {\n        if (this.lastMove !== null) {\n          return nextMoves2[this.lastMove / 3 | 0];\n        } else {\n          return allMoves2;\n        }\n      }\n\n      // Compute the minimum number of moves to the solved cube\n      minDist2() {\n        var d1, d2, index1, index2;\n        index1 = (N_SLICE2 * this.URtoDF + this.FRtoBR) * N_PARITY + this.parity;\n        d1 = this.pruning('sliceURtoDFParity', index1);\n        index2 = (N_SLICE2 * this.URFtoDLF + this.FRtoBR) * N_PARITY + this.parity;\n        d2 = this.pruning('sliceURFtoDLFParity', index2);\n        return max(d1, d2);\n      }\n\n      // Initialize phase 2 coordinates\n      init2(top = true) {\n        if (this.parent === null) {\n          return;\n        }\n        // For other states, the phase 2 state is computed based on\n        // parent's state.\n        // Already assigned for the initial state\n        this.parent.init2(false);\n        this.URFtoDLF = this.move('URFtoDLF', this.parent.URFtoDLF, this.lastMove);\n        this.FRtoBR = this.move('FRtoBR', this.parent.FRtoBR, this.lastMove);\n        this.parity = this.move('parity', this.parent.parity, this.lastMove);\n        this.URtoUL = this.move('URtoUL', this.parent.URtoUL, this.lastMove);\n        this.UBtoDF = this.move('UBtoDF', this.parent.UBtoDF, this.lastMove);\n        if (top) {\n          // This is the initial phase 2 state. Get the URtoDF coordinate\n          // by merging URtoUL and UBtoDF\n          return this.URtoDF = this.move('mergeURtoDF', this.URtoUL, this.UBtoDF);\n        }\n      }\n\n      // Compute the next phase 2 state for the given move\n      next2(move) {\n        var next;\n        next = freeStates.pop();\n        next.parent = this;\n        next.lastMove = move;\n        next.depth = this.depth + 1;\n        next.URFtoDLF = this.move('URFtoDLF', this.URFtoDLF, move);\n        next.FRtoBR = this.move('FRtoBR', this.FRtoBR, move);\n        next.parity = this.move('parity', this.parity, move);\n        next.URtoDF = this.move('URtoDF', this.URtoDF, move);\n        return next;\n      }\n\n    };\n    solution = null;\n    phase1search = function(state) {\n      var depth, m, ref, results;\n      depth = 0;\n      results = [];\n      for (depth = m = 1, ref = maxDepth; (1 <= ref ? m <= ref : m >= ref); depth = 1 <= ref ? ++m : --m) {\n        phase1(state, depth);\n        if (solution !== null) {\n          break;\n        }\n        results.push(depth++);\n      }\n      return results;\n    };\n    phase1 = function(state, depth) {\n      var len, m, move, next, ref, ref1, results;\n      if (depth === 0) {\n        if (state.minDist1() === 0) {\n          // Make sure we don't start phase 2 with a phase 2 move as the\n          // last move in phase 1, because phase 2 would then repeat the\n          // same move.\n          if (state.lastMove === null || (ref = state.lastMove, indexOf.call(allMoves2, ref) < 0)) {\n            return phase2search(state);\n          }\n        }\n      } else if (depth > 0) {\n        if (state.minDist1() <= depth) {\n          ref1 = state.moves1();\n          results = [];\n          for (m = 0, len = ref1.length; m < len; m++) {\n            move = ref1[m];\n            next = state.next1(move);\n            phase1(next, depth - 1);\n            freeStates.push(next);\n            if (solution !== null) {\n              break;\n            } else {\n              results.push(void 0);\n            }\n          }\n          return results;\n        }\n      }\n    };\n    phase2search = function(state) {\n      var depth, m, ref, results;\n      // Initialize phase 2 coordinates\n      state.init2();\n      results = [];\n      for (depth = m = 1, ref = maxDepth - state.depth; (1 <= ref ? m <= ref : m >= ref); depth = 1 <= ref ? ++m : --m) {\n        phase2(state, depth);\n        if (solution !== null) {\n          break;\n        }\n        results.push(depth++);\n      }\n      return results;\n    };\n    phase2 = function(state, depth) {\n      var len, m, move, next, ref, results;\n      if (depth === 0) {\n        if (state.minDist2() === 0) {\n          return solution = state.solution();\n        }\n      } else if (depth > 0) {\n        if (state.minDist2() <= depth) {\n          ref = state.moves2();\n          results = [];\n          for (m = 0, len = ref.length; m < len; m++) {\n            move = ref[m];\n            next = state.next2(move);\n            phase2(next, depth - 1);\n            freeStates.push(next);\n            if (solution !== null) {\n              break;\n            } else {\n              results.push(void 0);\n            }\n          }\n          return results;\n        }\n      }\n    };\n    freeStates = (function() {\n      var m, ref, results;\n      results = [];\n      for (x = m = 0, ref = maxDepth + 1; (0 <= ref ? m <= ref : m >= ref); x = 0 <= ref ? ++m : --m) {\n        results.push(new State);\n      }\n      return results;\n    })();\n    state = freeStates.pop().init(this);\n    phase1search(state);\n    freeStates.push(state);\n    // Trim the trailing space\n    if (solution.length > 0) {\n      solution = solution.substring(0, solution.length - 1);\n    }\n    return solution;\n  };\n\n  faceNums = {\n    U: 0,\n    R: 1,\n    F: 2,\n    D: 3,\n    L: 4,\n    B: 5\n  };\n\n  faceNames = {\n    0: 'U',\n    1: 'R',\n    2: 'F',\n    3: 'D',\n    4: 'L',\n    5: 'B'\n  };\n\n  Cube.prototype.solve = function(maxDepth = 22) {\n    var clone, len, m, move, ref, rotation, solution, upright, uprightSolution;\n    clone = this.clone();\n    upright = clone.upright();\n    clone.move(upright);\n    rotation = new Cube().move(upright).center;\n    uprightSolution = clone.solveUpright(maxDepth);\n    solution = [];\n    ref = uprightSolution.split(' ');\n    for (m = 0, len = ref.length; m < len; m++) {\n      move = ref[m];\n      solution.push(faceNames[rotation[faceNums[move[0]]]]);\n      if (move.length > 1) {\n        solution[solution.length - 1] += move[1];\n      }\n    }\n    return solution.join(' ');\n  };\n\n  Cube.scramble = function() {\n    return Cube.inverse(Cube.random().solve());\n  };\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3ViZWpzL2xpYi9zb2x2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsdURBQVE7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1Q0FBdUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUNBQXVDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQ0FBa0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQ0FBa0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUNBQXFDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQ0FBcUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0NBQXNDLCtCQUErQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1Q0FBdUMscUNBQXFDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQkFBK0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHlDQUF5QyxxQ0FBcUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQ0FBZ0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRiwrQ0FBK0Msd0NBQXdDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVDQUF1QztBQUNuRiw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0NBQWtDO0FBQ3RFO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsa0JBQWtCOztBQUVsQixpQkFBaUI7O0FBRWpCLGdCQUFnQjs7QUFFaEIsb0JBQW9COztBQUVwQixrQkFBa0I7O0FBRWxCLGlCQUFpQjs7QUFFakIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCLG1CQUFtQjs7QUFFbkIsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQ0FBa0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtDQUFrQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakMsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0NBQWtDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsa0NBQWtDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtDQUFrQztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvbWluYXJpemsvRG93bmxvYWRzL3J1YmlrbmV4dC9ub2RlX21vZHVsZXMvY3ViZWpzL2xpYi9zb2x2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIHZhciBCLCBCTCwgQlIsIENuaywgQ3ViZSwgRCwgREIsIERCTCwgREYsIERGUiwgREwsIERMRiwgRFIsIERSQiwgRiwgRkwsIEZSLCBJbmNsdWRlLCBMLCBOX0ZMSVAsIE5fRlJ0b0JSLCBOX1BBUklUWSwgTl9TTElDRTEsIE5fU0xJQ0UyLCBOX1RXSVNULCBOX1VCdG9ERiwgTl9VUkZ0b0RMRiwgTl9VUnRvREYsIE5fVVJ0b1VMLCBSLCBVLCBVQiwgVUJSLCBVRiwgVUZMLCBVTCwgVUxCLCBVUiwgVVJGLCBhbGxNb3ZlczEsIGFsbE1vdmVzMiwgY29tcHV0ZU1vdmVUYWJsZSwgY29tcHV0ZVBydW5pbmdUYWJsZSwgZmFjZU5hbWVzLCBmYWNlTnVtcywgZmFjdG9yaWFsLCBrZXksIG1heCwgbWVyZ2VVUnRvREYsIG1vdmVUYWJsZVBhcmFtcywgbmV4dE1vdmVzMSwgbmV4dE1vdmVzMiwgcGVybXV0YXRpb25JbmRleCwgcHJ1bmluZywgcHJ1bmluZ1RhYmxlUGFyYW1zLCByb3RhdGVMZWZ0LCByb3RhdGVSaWdodCwgdmFsdWUsXG4gICAgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbiAgQ3ViZSA9IHRoaXMuQ3ViZSB8fCByZXF1aXJlKCcuL2N1YmUnKTtcblxuICAvLyBDZW50ZXJzXG4gIFtVLCBSLCBGLCBELCBMLCBCXSA9IFswLCAxLCAyLCAzLCA0LCA1XTtcblxuICAvLyBDb3JuZXJzXG4gIFtVUkYsIFVGTCwgVUxCLCBVQlIsIERGUiwgRExGLCBEQkwsIERSQl0gPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgN107XG5cbiAgLy8gRWRnZXNcbiAgW1VSLCBVRiwgVUwsIFVCLCBEUiwgREYsIERMLCBEQiwgRlIsIEZMLCBCTCwgQlJdID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV07XG5cbiAgLy8jIEhlbHBlcnNcblxuICAvLyBuIGNob29zZSBrLCBpLmUuIHRoZSBiaW5vbWlhbCBjb2VmZmllY2llbnRcbiAgQ25rID0gZnVuY3Rpb24obiwgaykge1xuICAgIHZhciBpLCBqLCBzO1xuICAgIGlmIChuIDwgaykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChrID4gbiAvIDIpIHtcbiAgICAgIGsgPSBuIC0gaztcbiAgICB9XG4gICAgcyA9IDE7XG4gICAgaSA9IG47XG4gICAgaiA9IDE7XG4gICAgd2hpbGUgKGkgIT09IG4gLSBrKSB7XG4gICAgICBzICo9IGk7XG4gICAgICBzIC89IGo7XG4gICAgICBpLS07XG4gICAgICBqKys7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9O1xuXG4gIC8vIG4hXG4gIGZhY3RvcmlhbCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgZiwgaSwgbSwgcmVmO1xuICAgIGYgPSAxO1xuICAgIGZvciAoaSA9IG0gPSAyLCByZWYgPSBuOyAoMiA8PSByZWYgPyBtIDw9IHJlZiA6IG0gPj0gcmVmKTsgaSA9IDIgPD0gcmVmID8gKyttIDogLS1tKSB7XG4gICAgICBmICo9IGk7XG4gICAgfVxuICAgIHJldHVybiBmO1xuICB9O1xuXG4gIC8vIE1heGltdW0gb2YgdHdvIHZhbHVlc1xuICBtYXggPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJvdGF0ZSBlbGVtZW50cyBiZXR3ZWVuIGwgYW5kIHIgbGVmdCBieSBvbmUgcGxhY2VcbiAgcm90YXRlTGVmdCA9IGZ1bmN0aW9uKGFycmF5LCBsLCByKSB7XG4gICAgdmFyIGksIG0sIHJlZiwgcmVmMSwgdG1wO1xuICAgIHRtcCA9IGFycmF5W2xdO1xuICAgIGZvciAoaSA9IG0gPSByZWYgPSBsLCByZWYxID0gciAtIDE7IChyZWYgPD0gcmVmMSA/IG0gPD0gcmVmMSA6IG0gPj0gcmVmMSk7IGkgPSByZWYgPD0gcmVmMSA/ICsrbSA6IC0tbSkge1xuICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVtyXSA9IHRtcDtcbiAgfTtcblxuICAvLyBSb3RhdGUgZWxlbWVudHMgYmV0d2VlbiBsIGFuZCByIHJpZ2h0IGJ5IG9uZSBwbGFjZVxuICByb3RhdGVSaWdodCA9IGZ1bmN0aW9uKGFycmF5LCBsLCByKSB7XG4gICAgdmFyIGksIG0sIHJlZiwgcmVmMSwgdG1wO1xuICAgIHRtcCA9IGFycmF5W3JdO1xuICAgIGZvciAoaSA9IG0gPSByZWYgPSByLCByZWYxID0gbCArIDE7IChyZWYgPD0gcmVmMSA/IG0gPD0gcmVmMSA6IG0gPj0gcmVmMSk7IGkgPSByZWYgPD0gcmVmMSA/ICsrbSA6IC0tbSkge1xuICAgICAgYXJyYXlbaV0gPSBhcnJheVtpIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVtsXSA9IHRtcDtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgcGVybXV0YXRpb24gaW5kaWNlcy5cblxuICAvLyBUaGUgcGVybXV0YXRpb24gaW5kZXggYWN0dWFsbHkgZW5jb2RlcyB0d28gaW5kaWNlczogQ29tYmluYXRpb24sXG4gIC8vIGkuZS4gcG9zaXRpb25zIG9mIHRoZSBjdWJpZXMgc3RhcnQuLmVuZCAoQSkgYW5kIHRoZWlyIHJlc3BlY3RpdmVcbiAgLy8gcGVybXV0YXRpb24gKEIpLiBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgQiBpc1xuXG4gIC8vICAgbWF4QiA9IChlbmQgLSBzdGFydCArIDEpIVxuXG4gIC8vIGFuZCB0aGUgaW5kZXggaXMgQSAqIG1heEIgKyBCXG4gIHBlcm11dGF0aW9uSW5kZXggPSBmdW5jdGlvbihjb250ZXh0LCBzdGFydCwgZW5kLCBmcm9tRW5kID0gZmFsc2UpIHtcbiAgICB2YXIgaSwgbWF4QWxsLCBtYXhCLCBtYXhPdXIsIG91ciwgcGVybU5hbWU7XG4gICAgbWF4T3VyID0gZW5kIC0gc3RhcnQ7XG4gICAgbWF4QiA9IGZhY3RvcmlhbChtYXhPdXIgKyAxKTtcbiAgICBpZiAoY29udGV4dCA9PT0gJ2Nvcm5lcnMnKSB7XG4gICAgICBtYXhBbGwgPSA3O1xuICAgICAgcGVybU5hbWUgPSAnY3AnO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhBbGwgPSAxMTtcbiAgICAgIHBlcm1OYW1lID0gJ2VwJztcbiAgICB9XG4gICAgb3VyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG0sIHJlZiwgcmVzdWx0cztcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IG0gPSAwLCByZWYgPSBtYXhPdXI7ICgwIDw9IHJlZiA/IG0gPD0gcmVmIDogbSA+PSByZWYpOyBpID0gMCA8PSByZWYgPyArK20gOiAtLW0pIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHZhciBhLCBiLCBjLCBqLCBrLCBtLCBvLCBwLCBwZXJtLCBxLCByZWYsIHJlZjEsIHJlZjEwLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCByZWY2LCByZWY3LCByZWY4LCByZWY5LCB0LCB1LCB3LCB4LCB5LCB6O1xuICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gbSA9IDAsIHJlZiA9IG1heE91cjsgKDAgPD0gcmVmID8gbSA8PSByZWYgOiBtID49IHJlZik7IGkgPSAwIDw9IHJlZiA/ICsrbSA6IC0tbSkge1xuICAgICAgICAgIC8vIFJlc2V0IG91ciB0byBbc3RhcnQuLmVuZF1cbiAgICAgICAgICBvdXJbaV0gPSBpICsgc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgYiA9IGluZGV4ICUgbWF4QjsgLy8gcGVybXV0YXRpb25cbiAgICAgICAgYSA9IGluZGV4IC8gbWF4QiB8IDA7IC8vIGNvbWJpbmF0aW9uXG4gICAgICAgIFxuICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCBlZGdlc1xuICAgICAgICBwZXJtID0gdGhpc1twZXJtTmFtZV07XG4gICAgICAgIGZvciAoaSA9IG8gPSAwLCByZWYxID0gbWF4QWxsOyAoMCA8PSByZWYxID8gbyA8PSByZWYxIDogbyA+PSByZWYxKTsgaSA9IDAgPD0gcmVmMSA/ICsrbyA6IC0tbykge1xuICAgICAgICAgIHBlcm1baV0gPSAtMTtcbiAgICAgICAgfVxuLy8gR2VuZXJhdGUgcGVybXV0YXRpb24gZnJvbSBpbmRleCBiXG4gICAgICAgIGZvciAoaiA9IHAgPSAxLCByZWYyID0gbWF4T3VyOyAoMSA8PSByZWYyID8gcCA8PSByZWYyIDogcCA+PSByZWYyKTsgaiA9IDEgPD0gcmVmMiA/ICsrcCA6IC0tcCkge1xuICAgICAgICAgIGsgPSBiICUgKGogKyAxKTtcbiAgICAgICAgICBiID0gYiAvIChqICsgMSkgfCAwO1xuICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCByb3RhdGVSaWdodEJ5KG91ciwgMCwgaiwgaylcbiAgICAgICAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgICAgICAgIHJvdGF0ZVJpZ2h0KG91ciwgMCwgaik7XG4gICAgICAgICAgICBrLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEdlbmVyYXRlIGNvbWJpbmF0aW9uIGFuZCBzZXQgb3VyIGVkZ2VzXG4gICAgICAgIHggPSBtYXhPdXI7XG4gICAgICAgIGlmIChmcm9tRW5kKSB7XG4gICAgICAgICAgZm9yIChqID0gcSA9IDAsIHJlZjMgPSBtYXhBbGw7ICgwIDw9IHJlZjMgPyBxIDw9IHJlZjMgOiBxID49IHJlZjMpOyBqID0gMCA8PSByZWYzID8gKytxIDogLS1xKSB7XG4gICAgICAgICAgICBjID0gQ25rKG1heEFsbCAtIGosIHggKyAxKTtcbiAgICAgICAgICAgIGlmIChhIC0gYyA+PSAwKSB7XG4gICAgICAgICAgICAgIHBlcm1bal0gPSBvdXJbbWF4T3VyIC0geF07XG4gICAgICAgICAgICAgIGEgLT0gYztcbiAgICAgICAgICAgICAgeC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSB0ID0gcmVmNCA9IG1heEFsbDsgKHJlZjQgPD0gMCA/IHQgPD0gMCA6IHQgPj0gMCk7IGogPSByZWY0IDw9IDAgPyArK3QgOiAtLXQpIHtcbiAgICAgICAgICAgIGMgPSBDbmsoaiwgeCArIDEpO1xuICAgICAgICAgICAgaWYgKGEgLSBjID49IDApIHtcbiAgICAgICAgICAgICAgcGVybVtqXSA9IG91clt4XTtcbiAgICAgICAgICAgICAgYSAtPSBjO1xuICAgICAgICAgICAgICB4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVybSA9IHRoaXNbcGVybU5hbWVdO1xuICAgICAgICBmb3IgKGkgPSB1ID0gMCwgcmVmNSA9IG1heE91cjsgKDAgPD0gcmVmNSA/IHUgPD0gcmVmNSA6IHUgPj0gcmVmNSk7IGkgPSAwIDw9IHJlZjUgPyArK3UgOiAtLXUpIHtcbiAgICAgICAgICBvdXJbaV0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBhID0gYiA9IHggPSAwO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBpbmRleCBhIDwgKChtYXhBbGwgKyAxKSBjaG9vc2UgKG1heE91ciArIDEpKSBhbmRcbiAgICAgICAgLy8gdGhlIHBlcm11dGF0aW9uXG4gICAgICAgIGlmIChmcm9tRW5kKSB7XG4gICAgICAgICAgZm9yIChqID0gdyA9IHJlZjYgPSBtYXhBbGw7IChyZWY2IDw9IDAgPyB3IDw9IDAgOiB3ID49IDApOyBqID0gcmVmNiA8PSAwID8gKyt3IDogLS13KSB7XG4gICAgICAgICAgICBpZiAoKHN0YXJ0IDw9IChyZWY3ID0gcGVybVtqXSkgJiYgcmVmNyA8PSBlbmQpKSB7XG4gICAgICAgICAgICAgIGEgKz0gQ25rKG1heEFsbCAtIGosIHggKyAxKTtcbiAgICAgICAgICAgICAgb3VyW21heE91ciAtIHhdID0gcGVybVtqXTtcbiAgICAgICAgICAgICAgeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSB5ID0gMCwgcmVmOCA9IG1heEFsbDsgKDAgPD0gcmVmOCA/IHkgPD0gcmVmOCA6IHkgPj0gcmVmOCk7IGogPSAwIDw9IHJlZjggPyArK3kgOiAtLXkpIHtcbiAgICAgICAgICAgIGlmICgoc3RhcnQgPD0gKHJlZjkgPSBwZXJtW2pdKSAmJiByZWY5IDw9IGVuZCkpIHtcbiAgICAgICAgICAgICAgYSArPSBDbmsoaiwgeCArIDEpO1xuICAgICAgICAgICAgICBvdXJbeF0gPSBwZXJtW2pdO1xuICAgICAgICAgICAgICB4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4vLyBDb21wdXRlIHRoZSBpbmRleCBiIDwgKG1heE91ciArIDEpISBmb3IgdGhlIHBlcm11dGF0aW9uXG4gICAgICAgIGZvciAoaiA9IHogPSByZWYxMCA9IG1heE91cjsgKHJlZjEwIDw9IDAgPyB6IDw9IDAgOiB6ID49IDApOyBqID0gcmVmMTAgPD0gMCA/ICsreiA6IC0teikge1xuICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgIHdoaWxlIChvdXJbal0gIT09IHN0YXJ0ICsgaikge1xuICAgICAgICAgICAgcm90YXRlTGVmdChvdXIsIDAsIGopO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiID0gKGogKyAxKSAqIGIgKyBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhICogbWF4QiArIGI7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBJbmNsdWRlID0ge1xuICAgIC8vIFRoZSB0d2lzdCBvZiB0aGUgOCBjb3JuZXJzLCAwIDw9IHR3aXN0IDwgM143LiBUaGUgb3JpZW50YXRpb24gb2ZcbiAgICAvLyB0aGUgRFJCIGNvcm5lciBpcyBmdWxseSBkZXRlcm1pbmVkIGJ5IHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgb3RoZXJcbiAgICAvLyBjb3JuZXJzLlxuICAgIHR3aXN0OiBmdW5jdGlvbih0d2lzdCkge1xuICAgICAgdmFyIGksIG0sIG8sIG9yaSwgcGFyaXR5LCB2O1xuICAgICAgaWYgKHR3aXN0ICE9IG51bGwpIHtcbiAgICAgICAgcGFyaXR5ID0gMDtcbiAgICAgICAgZm9yIChpID0gbSA9IDY7IG0gPj0gMDsgaSA9IC0tbSkge1xuICAgICAgICAgIG9yaSA9IHR3aXN0ICUgMztcbiAgICAgICAgICB0d2lzdCA9ICh0d2lzdCAvIDMpIHwgMDtcbiAgICAgICAgICB0aGlzLmNvW2ldID0gb3JpO1xuICAgICAgICAgIHBhcml0eSArPSBvcmk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb1s3XSA9ICgzIC0gcGFyaXR5ICUgMykgJSAzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAwO1xuICAgICAgICBmb3IgKGkgPSBvID0gMDsgbyA8PSA2OyBpID0gKytvKSB7XG4gICAgICAgICAgdiA9IDMgKiB2ICsgdGhpcy5jb1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFRoZSBmbGlwIG9mIHRoZSAxMiBlZGdlcywgMCA8PSBmbGlwIDwgMl4xMS4gVGhlIG9yaWVudGF0aW9uIG9mIHRoZVxuICAgIC8vIEJSIGVkZ2UgaXMgZnVsbHkgZGV0ZXJtaW5lZCBieSB0aGUgb3JpZW50YXRpb24gb2YgdGhlIG90aGVyIGVkZ2VzLlxuICAgIGZsaXA6IGZ1bmN0aW9uKGZsaXApIHtcbiAgICAgIHZhciBpLCBtLCBvLCBvcmksIHBhcml0eSwgdjtcbiAgICAgIGlmIChmbGlwICE9IG51bGwpIHtcbiAgICAgICAgcGFyaXR5ID0gMDtcbiAgICAgICAgZm9yIChpID0gbSA9IDEwOyBtID49IDA7IGkgPSAtLW0pIHtcbiAgICAgICAgICBvcmkgPSBmbGlwICUgMjtcbiAgICAgICAgICBmbGlwID0gZmxpcCAvIDIgfCAwO1xuICAgICAgICAgIHRoaXMuZW9baV0gPSBvcmk7XG4gICAgICAgICAgcGFyaXR5ICs9IG9yaTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVvWzExXSA9ICgyIC0gcGFyaXR5ICUgMikgJSAyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAwO1xuICAgICAgICBmb3IgKGkgPSBvID0gMDsgbyA8PSAxMDsgaSA9ICsrbykge1xuICAgICAgICAgIHYgPSAyICogdiArIHRoaXMuZW9baV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBQYXJpdHkgb2YgdGhlIGNvcm5lciBwZXJtdXRhdGlvblxuICAgIGNvcm5lclBhcml0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgaiwgbSwgbywgcmVmLCByZWYxLCByZWYyLCByZWYzLCBzO1xuICAgICAgcyA9IDA7XG4gICAgICBmb3IgKGkgPSBtID0gcmVmID0gRFJCLCByZWYxID0gVVJGICsgMTsgKHJlZiA8PSByZWYxID8gbSA8PSByZWYxIDogbSA+PSByZWYxKTsgaSA9IHJlZiA8PSByZWYxID8gKyttIDogLS1tKSB7XG4gICAgICAgIGZvciAoaiA9IG8gPSByZWYyID0gaSAtIDEsIHJlZjMgPSBVUkY7IChyZWYyIDw9IHJlZjMgPyBvIDw9IHJlZjMgOiBvID49IHJlZjMpOyBqID0gcmVmMiA8PSByZWYzID8gKytvIDogLS1vKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY3Bbal0gPiB0aGlzLmNwW2ldKSB7XG4gICAgICAgICAgICBzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcyAlIDI7XG4gICAgfSxcbiAgICAvLyBQYXJpdHkgb2YgdGhlIGVkZ2VzIHBlcm11dGF0aW9uLiBQYXJpdHkgb2YgY29ybmVycyBhbmQgZWRnZXMgYXJlXG4gICAgLy8gdGhlIHNhbWUgaWYgdGhlIGN1YmUgaXMgc29sdmFibGUuXG4gICAgZWRnZVBhcml0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgaiwgbSwgbywgcmVmLCByZWYxLCByZWYyLCByZWYzLCBzO1xuICAgICAgcyA9IDA7XG4gICAgICBmb3IgKGkgPSBtID0gcmVmID0gQlIsIHJlZjEgPSBVUiArIDE7IChyZWYgPD0gcmVmMSA/IG0gPD0gcmVmMSA6IG0gPj0gcmVmMSk7IGkgPSByZWYgPD0gcmVmMSA/ICsrbSA6IC0tbSkge1xuICAgICAgICBmb3IgKGogPSBvID0gcmVmMiA9IGkgLSAxLCByZWYzID0gVVI7IChyZWYyIDw9IHJlZjMgPyBvIDw9IHJlZjMgOiBvID49IHJlZjMpOyBqID0gcmVmMiA8PSByZWYzID8gKytvIDogLS1vKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXBbal0gPiB0aGlzLmVwW2ldKSB7XG4gICAgICAgICAgICBzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcyAlIDI7XG4gICAgfSxcbiAgICAvLyBQZXJtdXRhdGlvbiBvZiB0aGUgc2l4IGNvcm5lcnMgVVJGLCBVRkwsIFVMQiwgVUJSLCBERlIsIERMRlxuICAgIFVSRnRvRExGOiBwZXJtdXRhdGlvbkluZGV4KCdjb3JuZXJzJywgVVJGLCBETEYpLFxuICAgIC8vIFBlcm11dGF0aW9uIG9mIHRoZSB0aHJlZSBlZGdlcyBVUiwgVUYsIFVMXG4gICAgVVJ0b1VMOiBwZXJtdXRhdGlvbkluZGV4KCdlZGdlcycsIFVSLCBVTCksXG4gICAgLy8gUGVybXV0YXRpb24gb2YgdGhlIHRocmVlIGVkZ2VzIFVCLCBEUiwgREZcbiAgICBVQnRvREY6IHBlcm11dGF0aW9uSW5kZXgoJ2VkZ2VzJywgVUIsIERGKSxcbiAgICAvLyBQZXJtdXRhdGlvbiBvZiB0aGUgc2l4IGVkZ2VzIFVSLCBVRiwgVUwsIFVCLCBEUiwgREZcbiAgICBVUnRvREY6IHBlcm11dGF0aW9uSW5kZXgoJ2VkZ2VzJywgVVIsIERGKSxcbiAgICAvLyBQZXJtdXRhdGlvbiBvZiB0aGUgZXF1YXRvciBzbGljZSBlZGdlcyBGUiwgRkwsIEJMIGFuZCBCUlxuICAgIEZSdG9CUjogcGVybXV0YXRpb25JbmRleCgnZWRnZXMnLCBGUiwgQlIsIHRydWUpXG4gIH07XG5cbiAgZm9yIChrZXkgaW4gSW5jbHVkZSkge1xuICAgIHZhbHVlID0gSW5jbHVkZVtrZXldO1xuICAgIEN1YmUucHJvdG90eXBlW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGNvbXB1dGVNb3ZlVGFibGUgPSBmdW5jdGlvbihjb250ZXh0LCBjb29yZCwgc2l6ZSkge1xuICAgIHZhciBhcHBseSwgY3ViZSwgaSwgaW5uZXIsIGosIGssIG0sIG1vdmUsIG8sIHAsIHJlZiwgcmVzdWx0cztcbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIHZhbGlkIHZhbHVlcyBmb3IgdGhlIGNvb3JkaW5hdGUsIHNldHRpbmcgY3ViZSdzXG4gICAgLy8gc3RhdGUgaW4gZWFjaCBpdGVyYXRpb24uIFRoZW4gYXBwbHkgZWFjaCBvZiB0aGUgMTggbW92ZXMgdG8gdGhlXG4gICAgLy8gY3ViZSwgYW5kIGNvbXB1dGUgdGhlIHJlc3VsdGluZyBjb29yZGluYXRlLlxuICAgIGFwcGx5ID0gY29udGV4dCA9PT0gJ2Nvcm5lcnMnID8gJ2Nvcm5lck11bHRpcGx5JyA6ICdlZGdlTXVsdGlwbHknO1xuICAgIGN1YmUgPSBuZXcgQ3ViZTtcbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yIChpID0gbSA9IDAsIHJlZiA9IHNpemUgLSAxOyAoMCA8PSByZWYgPyBtIDw9IHJlZiA6IG0gPj0gcmVmKTsgaSA9IDAgPD0gcmVmID8gKyttIDogLS1tKSB7XG4gICAgICBjdWJlW2Nvb3JkXShpKTtcbiAgICAgIGlubmVyID0gW107XG4gICAgICBmb3IgKGogPSBvID0gMDsgbyA8PSA1OyBqID0gKytvKSB7XG4gICAgICAgIG1vdmUgPSBDdWJlLm1vdmVzW2pdO1xuICAgICAgICBmb3IgKGsgPSBwID0gMDsgcCA8PSAyOyBrID0gKytwKSB7XG4gICAgICAgICAgY3ViZVthcHBseV0obW92ZSk7XG4gICAgICAgICAgaW5uZXIucHVzaChjdWJlW2Nvb3JkXSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA0dGggZmFjZSB0dXJuIHJlc3RvcmVzIHRoZSBjdWJlXG4gICAgICAgIGN1YmVbYXBwbHldKG1vdmUpO1xuICAgICAgfVxuICAgICAgcmVzdWx0cy5wdXNoKGlubmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQmVjYXVzZSB3ZSBvbmx5IGhhdmUgdGhlIHBoYXNlIDIgVVJ0b0RGIGNvb3JkaW5hdGVzLCB3ZSBuZWVkIHRvXG4gIC8vIG1lcmdlIHRoZSBVUnRvVUwgYW5kIFVCdG9ERiBjb29yZGluYXRlcyB0byBVUnRvREYgaW4gdGhlIGJlZ2lubmluZ1xuICAvLyBvZiBwaGFzZSAyLlxuICBtZXJnZVVSdG9ERiA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgYSwgYjtcbiAgICBhID0gbmV3IEN1YmU7XG4gICAgYiA9IG5ldyBDdWJlO1xuICAgIHJldHVybiBmdW5jdGlvbihVUnRvVUwsIFVCdG9ERikge1xuICAgICAgdmFyIGksIG07XG4gICAgICAvLyBDb2xsaXNpb25zIGNhbiBiZSBmb3VuZCBiZWNhdXNlIHVuc2V0IGFyZSBzZXQgdG8gLTFcbiAgICAgIGEuVVJ0b1VMKFVSdG9VTCk7XG4gICAgICBiLlVCdG9ERihVQnRvREYpO1xuICAgICAgZm9yIChpID0gbSA9IDA7IG0gPD0gNzsgaSA9ICsrbSkge1xuICAgICAgICBpZiAoYS5lcFtpXSAhPT0gLTEpIHtcbiAgICAgICAgICBpZiAoYi5lcFtpXSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTsgLy8gY29sbGlzaW9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGIuZXBbaV0gPSBhLmVwW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGIuVVJ0b0RGKCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICBOX1RXSVNUID0gMjE4NzsgLy8gM143IGNvcm5lciBvcmllbnRhdGlvbnNcblxuICBOX0ZMSVAgPSAyMDQ4OyAvLyAyXjExIHBvc3NpYmxlIGVkZ2UgZmxpcHNcblxuICBOX1BBUklUWSA9IDI7IC8vIDIgcG9zc2libGUgcGFyaXRpZXNcblxuICBOX0ZSdG9CUiA9IDExODgwOyAvLyAxMiEvKDEyLTQpISBwZXJtdXRhdGlvbnMgb2YgRlIuLkJSIGVkZ2VzXG5cbiAgTl9TTElDRTEgPSA0OTU7IC8vICgxMiBjaG9vc2UgNCkgcG9zc2libGUgcG9zaXRpb25zIG9mIEZSLi5CUiBlZGdlc1xuXG4gIE5fU0xJQ0UyID0gMjQ7IC8vIDQhIHBlcm11dGF0aW9ucyBvZiBGUi4uQlIgZWRnZXMgaW4gcGhhc2UgMlxuXG4gIE5fVVJGdG9ETEYgPSAyMDE2MDsgLy8gOCEvKDgtNikhIHBlcm11dGF0aW9ucyBvZiBVUkYuLkRMRiBjb3JuZXJzXG5cbiAgXG4gIC8vIFRoZSBVUnRvREYgbW92ZSB0YWJsZSBpcyBvbmx5IGNvbXB1dGVkIGZvciBwaGFzZSAyIGJlY2F1c2UgdGhlIGZ1bGxcbiAgLy8gdGFibGUgd291bGQgaGF2ZSA+NjUwMDAwIGVudHJpZXNcbiAgTl9VUnRvREYgPSAyMDE2MDsgLy8gOCEvKDgtNikhIHBlcm11dGF0aW9uIG9mIFVSLi5ERiBlZGdlcyBpbiBwaGFzZSAyXG5cbiAgTl9VUnRvVUwgPSAxMzIwOyAvLyAxMiEvKDEyLTMpISBwZXJtdXRhdGlvbnMgb2YgVVIuLlVMIGVkZ2VzXG5cbiAgTl9VQnRvREYgPSAxMzIwOyAvLyAxMiEvKDEyLTMpISBwZXJtdXRhdGlvbnMgb2YgVUIuLkRGIGVkZ2VzXG5cbiAgXG4gIC8vIFRoZSBtb3ZlIHRhYmxlIGZvciBwYXJpdHkgaXMgc28gc21hbGwgdGhhdCBpdCdzIGluY2x1ZGVkIGhlcmVcbiAgQ3ViZS5tb3ZlVGFibGVzID0ge1xuICAgIHBhcml0eTogW1sxLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAxXSwgWzAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDBdXSxcbiAgICB0d2lzdDogbnVsbCxcbiAgICBmbGlwOiBudWxsLFxuICAgIEZSdG9CUjogbnVsbCxcbiAgICBVUkZ0b0RMRjogbnVsbCxcbiAgICBVUnRvREY6IG51bGwsXG4gICAgVVJ0b1VMOiBudWxsLFxuICAgIFVCdG9ERjogbnVsbCxcbiAgICBtZXJnZVVSdG9ERjogbnVsbFxuICB9O1xuXG4gIC8vIE90aGVyIG1vdmUgdGFibGVzIGFyZSBjb21wdXRlZCBvbiB0aGUgZmx5XG4gIG1vdmVUYWJsZVBhcmFtcyA9IHtcbiAgICAvLyBuYW1lOiBbc2NvcGUsIHNpemVdXG4gICAgdHdpc3Q6IFsnY29ybmVycycsIE5fVFdJU1RdLFxuICAgIGZsaXA6IFsnZWRnZXMnLCBOX0ZMSVBdLFxuICAgIEZSdG9CUjogWydlZGdlcycsIE5fRlJ0b0JSXSxcbiAgICBVUkZ0b0RMRjogWydjb3JuZXJzJywgTl9VUkZ0b0RMRl0sXG4gICAgVVJ0b0RGOiBbJ2VkZ2VzJywgTl9VUnRvREZdLFxuICAgIFVSdG9VTDogWydlZGdlcycsIE5fVVJ0b1VMXSxcbiAgICBVQnRvREY6IFsnZWRnZXMnLCBOX1VCdG9ERl0sXG4gICAgbWVyZ2VVUnRvREY6IFtdXG4gIH07XG5cbiAgQ3ViZS5jb21wdXRlTW92ZVRhYmxlcyA9IGZ1bmN0aW9uKC4uLnRhYmxlcykge1xuICAgIHZhciBsZW4sIG0sIG5hbWUsIHNjb3BlLCBzaXplLCB0YWJsZU5hbWU7XG4gICAgaWYgKHRhYmxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRhYmxlcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChuYW1lIGluIG1vdmVUYWJsZVBhcmFtcykge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0pKCk7XG4gICAgfVxuICAgIGZvciAobSA9IDAsIGxlbiA9IHRhYmxlcy5sZW5ndGg7IG0gPCBsZW47IG0rKykge1xuICAgICAgdGFibGVOYW1lID0gdGFibGVzW21dO1xuICAgICAgaWYgKHRoaXMubW92ZVRhYmxlc1t0YWJsZU5hbWVdICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFscmVhZHkgY29tcHV0ZWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGFibGVOYW1lID09PSAnbWVyZ2VVUnRvREYnKSB7XG4gICAgICAgIHRoaXMubW92ZVRhYmxlcy5tZXJnZVVSdG9ERiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgVUJ0b0RGLCBVUnRvVUwsIG8sIHJlc3VsdHM7XG4gICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoVVJ0b1VMID0gbyA9IDA7IG8gPD0gMzM1OyBVUnRvVUwgPSArK28pIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBwLCByZXN1bHRzMTtcbiAgICAgICAgICAgICAgcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChVQnRvREYgPSBwID0gMDsgcCA8PSAzMzU7IFVCdG9ERiA9ICsrcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMxLnB1c2gobWVyZ2VVUnRvREYoVVJ0b1VMLCBVQnRvREYpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0czE7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbc2NvcGUsIHNpemVdID0gbW92ZVRhYmxlUGFyYW1zW3RhYmxlTmFtZV07XG4gICAgICAgIHRoaXMubW92ZVRhYmxlc1t0YWJsZU5hbWVdID0gY29tcHV0ZU1vdmVUYWJsZShzY29wZSwgdGFibGVOYW1lLCBzaXplKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUGhhc2UgMTogQWxsIG1vdmVzIGFyZSB2YWxpZFxuICBhbGxNb3ZlczEgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3XTtcblxuICAvLyBUaGUgbGlzdCBvZiBuZXh0IHZhbGlkIHBoYXNlIDEgbW92ZXMgd2hlbiB0aGUgZ2l2ZW4gZmFjZSB3YXMgdHVybmVkXG4gIC8vIGluIHRoZSBsYXN0IG1vdmVcbiAgbmV4dE1vdmVzMSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZmFjZSwgbGFzdEZhY2UsIG0sIG5leHQsIG8sIHAsIHBvd2VyLCByZXN1bHRzO1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxhc3RGYWNlID0gbSA9IDA7IG0gPD0gNTsgbGFzdEZhY2UgPSArK20pIHtcbiAgICAgIG5leHQgPSBbXTtcbi8vIERvbid0IGFsbG93IGNvbW11dGluZyBtb3ZlcywgZS5nLiBVIFUnLiBBbHNvIG1ha2Ugc3VyZSB0aGF0XG4vLyBvcHBvc2l0ZSBmYWNlcyBhcmUgYWx3YXlzIG1vdmVkIGluIHRoZSBzYW1lIG9yZGVyLCBpLmUuIGFsbG93XG4vLyBVIEQgYnV0IG5vIEQgVS4gVGhpcyBhdm9pZHMgc2VxdWVuY2VzIGxpa2UgVSBEIFUnLlxuICAgICAgZm9yIChmYWNlID0gbyA9IDA7IG8gPD0gNTsgZmFjZSA9ICsrbykge1xuICAgICAgICBpZiAoZmFjZSAhPT0gbGFzdEZhY2UgJiYgZmFjZSAhPT0gbGFzdEZhY2UgLSAzKSB7XG4vLyBzaW5nbGUsIGRvdWJsZSBvciBpbnZlcnNlIG1vdmVcbiAgICAgICAgICBmb3IgKHBvd2VyID0gcCA9IDA7IHAgPD0gMjsgcG93ZXIgPSArK3ApIHtcbiAgICAgICAgICAgIG5leHQucHVzaChmYWNlICogMyArIHBvd2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdHMucHVzaChuZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0pKCk7XG5cbiAgLy8gUGhhc2UgMjogRG91YmxlIG1vdmVzIG9mIGFsbCBmYWNlcyBwbHVzIHF1YXJ0ZXIgbW92ZXMgb2YgVSBhbmQgRFxuICBhbGxNb3ZlczIgPSBbMCwgMSwgMiwgNCwgNywgOSwgMTAsIDExLCAxMywgMTZdO1xuXG4gIG5leHRNb3ZlczIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZhY2UsIGxhc3RGYWNlLCBsZW4sIG0sIG5leHQsIG8sIHAsIHBvd2VyLCBwb3dlcnMsIHJlc3VsdHM7XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGFzdEZhY2UgPSBtID0gMDsgbSA8PSA1OyBsYXN0RmFjZSA9ICsrbSkge1xuICAgICAgbmV4dCA9IFtdO1xuICAgICAgZm9yIChmYWNlID0gbyA9IDA7IG8gPD0gNTsgZmFjZSA9ICsrbykge1xuICAgICAgICBpZiAoIShmYWNlICE9PSBsYXN0RmFjZSAmJiBmYWNlICE9PSBsYXN0RmFjZSAtIDMpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb3cgYWxsIG1vdmVzIG9mIFUgYW5kIEQgYW5kIGRvdWJsZSBtb3ZlcyBvZiBvdGhlcnNcbiAgICAgICAgcG93ZXJzID0gZmFjZSA9PT0gMCB8fCBmYWNlID09PSAzID8gWzAsIDEsIDJdIDogWzFdO1xuICAgICAgICBmb3IgKHAgPSAwLCBsZW4gPSBwb3dlcnMubGVuZ3RoOyBwIDwgbGVuOyBwKyspIHtcbiAgICAgICAgICBwb3dlciA9IHBvd2Vyc1twXTtcbiAgICAgICAgICBuZXh0LnB1c2goZmFjZSAqIDMgKyBwb3dlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdHMucHVzaChuZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0pKCk7XG5cbiAgLy8gOCB2YWx1ZXMgYXJlIGVuY29kZWQgaW4gb25lIG51bWJlclxuICBwcnVuaW5nID0gZnVuY3Rpb24odGFibGUsIGluZGV4LCB2YWx1ZSkge1xuICAgIHZhciBwb3MsIHNoaWZ0LCBzbG90O1xuICAgIHBvcyA9IGluZGV4ICUgODtcbiAgICBzbG90ID0gaW5kZXggPj4gMztcbiAgICBzaGlmdCA9IHBvcyA8PCAyO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBTZXRcbiAgICAgIHRhYmxlW3Nsb3RdICY9IH4oMHhGIDw8IHNoaWZ0KTtcbiAgICAgIHRhYmxlW3Nsb3RdIHw9IHZhbHVlIDw8IHNoaWZ0O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZXRcbiAgICAgIHJldHVybiAodGFibGVbc2xvdF0gJiAoMHhGIDw8IHNoaWZ0KSkgPj4+IHNoaWZ0O1xuICAgIH1cbiAgfTtcblxuICBjb21wdXRlUHJ1bmluZ1RhYmxlID0gZnVuY3Rpb24ocGhhc2UsIHNpemUsIGN1cnJlbnRDb29yZHMsIG5leHRJbmRleCkge1xuICAgIHZhciBjdXJyZW50LCBkZXB0aCwgZG9uZSwgaW5kZXgsIGxlbiwgbSwgbW92ZSwgbW92ZXMsIG5leHQsIG8sIHJlZiwgdGFibGUsIHg7XG4gICAgLy8gSW5pdGlhbGl6ZSBhbGwgdmFsdWVzIHRvIDB4RlxuICAgIHRhYmxlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG0sIHJlZiwgcmVzdWx0cztcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoeCA9IG0gPSAwLCByZWYgPSBNYXRoLmNlaWwoc2l6ZSAvIDgpIC0gMTsgKDAgPD0gcmVmID8gbSA8PSByZWYgOiBtID49IHJlZik7IHggPSAwIDw9IHJlZiA/ICsrbSA6IC0tbSkge1xuICAgICAgICByZXN1bHRzLnB1c2goMHhGRkZGRkZGRik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KSgpO1xuICAgIGlmIChwaGFzZSA9PT0gMSkge1xuICAgICAgbW92ZXMgPSBhbGxNb3ZlczE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdmVzID0gYWxsTW92ZXMyO1xuICAgIH1cbiAgICBkZXB0aCA9IDA7XG4gICAgcHJ1bmluZyh0YWJsZSwgMCwgZGVwdGgpO1xuICAgIGRvbmUgPSAxO1xuICAgIC8vIEluIGVhY2ggaXRlcmF0aW9uLCB0YWtlIGVhY2ggc3RhdGUgZm91bmQgaW4gdGhlIHByZXZpb3VzIGRlcHRoIGFuZFxuICAgIC8vIGNvbXB1dGUgdGhlIG5leHQgc3RhdGUuIFN0b3Agd2hlbiBhbGwgc3RhdGVzIGhhdmUgYmVlbiBhc3NpZ25lZCBhXG4gICAgLy8gZGVwdGguXG4gICAgd2hpbGUgKGRvbmUgIT09IHNpemUpIHtcbiAgICAgIGZvciAoaW5kZXggPSBtID0gMCwgcmVmID0gc2l6ZSAtIDE7ICgwIDw9IHJlZiA/IG0gPD0gcmVmIDogbSA+PSByZWYpOyBpbmRleCA9IDAgPD0gcmVmID8gKyttIDogLS1tKSB7XG4gICAgICAgIGlmICghKHBydW5pbmcodGFibGUsIGluZGV4KSA9PT0gZGVwdGgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnRDb29yZHMoaW5kZXgpO1xuICAgICAgICBmb3IgKG8gPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IG8gPCBsZW47IG8rKykge1xuICAgICAgICAgIG1vdmUgPSBtb3Zlc1tvXTtcbiAgICAgICAgICBuZXh0ID0gbmV4dEluZGV4KGN1cnJlbnQsIG1vdmUpO1xuICAgICAgICAgIGlmIChwcnVuaW5nKHRhYmxlLCBuZXh0KSA9PT0gMHhGKSB7XG4gICAgICAgICAgICBwcnVuaW5nKHRhYmxlLCBuZXh0LCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgZG9uZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVwdGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9O1xuXG4gIEN1YmUucHJ1bmluZ1RhYmxlcyA9IHtcbiAgICBzbGljZVR3aXN0OiBudWxsLFxuICAgIHNsaWNlRmxpcDogbnVsbCxcbiAgICBzbGljZVVSRnRvRExGUGFyaXR5OiBudWxsLFxuICAgIHNsaWNlVVJ0b0RGUGFyaXR5OiBudWxsXG4gIH07XG5cbiAgcHJ1bmluZ1RhYmxlUGFyYW1zID0ge1xuICAgIC8vIG5hbWU6IFtwaGFzZSwgc2l6ZSwgY3VycmVudENvb3JkcywgbmV4dEluZGV4XVxuICAgIHNsaWNlVHdpc3Q6IFtcbiAgICAgIDEsXG4gICAgICBOX1NMSUNFMSAqIE5fVFdJU1QsXG4gICAgICBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gW2luZGV4ICUgTl9TTElDRTEsXG4gICAgICBpbmRleCAvIE5fU0xJQ0UxIHwgMF07XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oY3VycmVudCxcbiAgICAgIG1vdmUpIHtcbiAgICAgICAgdmFyIG5ld1NsaWNlLFxuICAgICAgbmV3VHdpc3QsXG4gICAgICBzbGljZSxcbiAgICAgIHR3aXN0O1xuICAgICAgICBbc2xpY2UsXG4gICAgICB0d2lzdF0gPSBjdXJyZW50O1xuICAgICAgICBuZXdTbGljZSA9IEN1YmUubW92ZVRhYmxlcy5GUnRvQlJbc2xpY2UgKiAyNF1bbW92ZV0gLyAyNCB8IDA7XG4gICAgICAgIG5ld1R3aXN0ID0gQ3ViZS5tb3ZlVGFibGVzLnR3aXN0W3R3aXN0XVttb3ZlXTtcbiAgICAgICAgcmV0dXJuIG5ld1R3aXN0ICogTl9TTElDRTEgKyBuZXdTbGljZTtcbiAgICAgIH1cbiAgICBdLFxuICAgIHNsaWNlRmxpcDogW1xuICAgICAgMSxcbiAgICAgIE5fU0xJQ0UxICogTl9GTElQLFxuICAgICAgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFtpbmRleCAlIE5fU0xJQ0UxLFxuICAgICAgaW5kZXggLyBOX1NMSUNFMSB8IDBdO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKGN1cnJlbnQsXG4gICAgICBtb3ZlKSB7XG4gICAgICAgIHZhciBmbGlwLFxuICAgICAgbmV3RmxpcCxcbiAgICAgIG5ld1NsaWNlLFxuICAgICAgc2xpY2U7XG4gICAgICAgIFtzbGljZSxcbiAgICAgIGZsaXBdID0gY3VycmVudDtcbiAgICAgICAgbmV3U2xpY2UgPSBDdWJlLm1vdmVUYWJsZXMuRlJ0b0JSW3NsaWNlICogMjRdW21vdmVdIC8gMjQgfCAwO1xuICAgICAgICBuZXdGbGlwID0gQ3ViZS5tb3ZlVGFibGVzLmZsaXBbZmxpcF1bbW92ZV07XG4gICAgICAgIHJldHVybiBuZXdGbGlwICogTl9TTElDRTEgKyBuZXdTbGljZTtcbiAgICAgIH1cbiAgICBdLFxuICAgIHNsaWNlVVJGdG9ETEZQYXJpdHk6IFtcbiAgICAgIDIsXG4gICAgICBOX1NMSUNFMiAqIE5fVVJGdG9ETEYgKiBOX1BBUklUWSxcbiAgICAgIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBbaW5kZXggJSAyLFxuICAgICAgKGluZGV4IC8gMiB8IDApICUgTl9TTElDRTIsXG4gICAgICAoaW5kZXggLyAyIHwgMCkgLyBOX1NMSUNFMiB8IDBdO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKGN1cnJlbnQsXG4gICAgICBtb3ZlKSB7XG4gICAgICAgIHZhciBVUkZ0b0RMRixcbiAgICAgIG5ld1Bhcml0eSxcbiAgICAgIG5ld1NsaWNlLFxuICAgICAgbmV3VVJGdG9ETEYsXG4gICAgICBwYXJpdHksXG4gICAgICBzbGljZTtcbiAgICAgICAgW3Bhcml0eSxcbiAgICAgIHNsaWNlLFxuICAgICAgVVJGdG9ETEZdID0gY3VycmVudDtcbiAgICAgICAgbmV3UGFyaXR5ID0gQ3ViZS5tb3ZlVGFibGVzLnBhcml0eVtwYXJpdHldW21vdmVdO1xuICAgICAgICBuZXdTbGljZSA9IEN1YmUubW92ZVRhYmxlcy5GUnRvQlJbc2xpY2VdW21vdmVdO1xuICAgICAgICBuZXdVUkZ0b0RMRiA9IEN1YmUubW92ZVRhYmxlcy5VUkZ0b0RMRltVUkZ0b0RMRl1bbW92ZV07XG4gICAgICAgIHJldHVybiAobmV3VVJGdG9ETEYgKiBOX1NMSUNFMiArIG5ld1NsaWNlKSAqIDIgKyBuZXdQYXJpdHk7XG4gICAgICB9XG4gICAgXSxcbiAgICBzbGljZVVSdG9ERlBhcml0eTogW1xuICAgICAgMixcbiAgICAgIE5fU0xJQ0UyICogTl9VUnRvREYgKiBOX1BBUklUWSxcbiAgICAgIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBbaW5kZXggJSAyLFxuICAgICAgKGluZGV4IC8gMiB8IDApICUgTl9TTElDRTIsXG4gICAgICAoaW5kZXggLyAyIHwgMCkgLyBOX1NMSUNFMiB8IDBdO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKGN1cnJlbnQsXG4gICAgICBtb3ZlKSB7XG4gICAgICAgIHZhciBVUnRvREYsXG4gICAgICBuZXdQYXJpdHksXG4gICAgICBuZXdTbGljZSxcbiAgICAgIG5ld1VSdG9ERixcbiAgICAgIHBhcml0eSxcbiAgICAgIHNsaWNlO1xuICAgICAgICBbcGFyaXR5LFxuICAgICAgc2xpY2UsXG4gICAgICBVUnRvREZdID0gY3VycmVudDtcbiAgICAgICAgbmV3UGFyaXR5ID0gQ3ViZS5tb3ZlVGFibGVzLnBhcml0eVtwYXJpdHldW21vdmVdO1xuICAgICAgICBuZXdTbGljZSA9IEN1YmUubW92ZVRhYmxlcy5GUnRvQlJbc2xpY2VdW21vdmVdO1xuICAgICAgICBuZXdVUnRvREYgPSBDdWJlLm1vdmVUYWJsZXMuVVJ0b0RGW1VSdG9ERl1bbW92ZV07XG4gICAgICAgIHJldHVybiAobmV3VVJ0b0RGICogTl9TTElDRTIgKyBuZXdTbGljZSkgKiAyICsgbmV3UGFyaXR5O1xuICAgICAgfVxuICAgIF1cbiAgfTtcblxuICBDdWJlLmNvbXB1dGVQcnVuaW5nVGFibGVzID0gZnVuY3Rpb24oLi4udGFibGVzKSB7XG4gICAgdmFyIGxlbiwgbSwgbmFtZSwgcGFyYW1zLCB0YWJsZU5hbWU7XG4gICAgaWYgKHRhYmxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRhYmxlcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChuYW1lIGluIHBydW5pbmdUYWJsZVBhcmFtcykge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0pKCk7XG4gICAgfVxuICAgIGZvciAobSA9IDAsIGxlbiA9IHRhYmxlcy5sZW5ndGg7IG0gPCBsZW47IG0rKykge1xuICAgICAgdGFibGVOYW1lID0gdGFibGVzW21dO1xuICAgICAgaWYgKHRoaXMucHJ1bmluZ1RhYmxlc1t0YWJsZU5hbWVdICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFscmVhZHkgY29tcHV0ZWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwYXJhbXMgPSBwcnVuaW5nVGFibGVQYXJhbXNbdGFibGVOYW1lXTtcbiAgICAgIHRoaXMucHJ1bmluZ1RhYmxlc1t0YWJsZU5hbWVdID0gY29tcHV0ZVBydW5pbmdUYWJsZSguLi5wYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDdWJlLmluaXRTb2x2ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBDdWJlLmNvbXB1dGVNb3ZlVGFibGVzKCk7XG4gICAgcmV0dXJuIEN1YmUuY29tcHV0ZVBydW5pbmdUYWJsZXMoKTtcbiAgfTtcblxuICBDdWJlLnByb3RvdHlwZS5zb2x2ZVVwcmlnaHQgPSBmdW5jdGlvbihtYXhEZXB0aCA9IDIyKSB7XG4gICAgdmFyIFN0YXRlLCBmcmVlU3RhdGVzLCBtb3ZlTmFtZXMsIHBoYXNlMSwgcGhhc2Uxc2VhcmNoLCBwaGFzZTIsIHBoYXNlMnNlYXJjaCwgc29sdXRpb24sIHN0YXRlLCB4O1xuICAgIC8vIE5hbWVzIGZvciBhbGwgbW92ZXMsIGkuZS4gVSwgVTIsIFUnLCBGLCBGMiwgLi4uXG4gICAgbW92ZU5hbWVzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZhY2UsIGZhY2VOYW1lLCBtLCBvLCBwb3dlciwgcG93ZXJOYW1lLCByZXN1bHQ7XG4gICAgICBmYWNlTmFtZSA9IFsnVScsICdSJywgJ0YnLCAnRCcsICdMJywgJ0InXTtcbiAgICAgIHBvd2VyTmFtZSA9IFsnJywgJzInLCBcIidcIl07XG4gICAgICByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoZmFjZSA9IG0gPSAwOyBtIDw9IDU7IGZhY2UgPSArK20pIHtcbiAgICAgICAgZm9yIChwb3dlciA9IG8gPSAwOyBvIDw9IDI7IHBvd2VyID0gKytvKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZmFjZU5hbWVbZmFjZV0gKyBwb3dlck5hbWVbcG93ZXJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KSgpO1xuICAgIFN0YXRlID0gY2xhc3MgU3RhdGUge1xuICAgICAgY29uc3RydWN0b3IoY3ViZSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSBudWxsO1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgaWYgKGN1YmUpIHtcbiAgICAgICAgICB0aGlzLmluaXQoY3ViZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5pdChjdWJlKSB7XG4gICAgICAgIC8vIFBoYXNlIDEgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5mbGlwID0gY3ViZS5mbGlwKCk7XG4gICAgICAgIHRoaXMudHdpc3QgPSBjdWJlLnR3aXN0KCk7XG4gICAgICAgIHRoaXMuc2xpY2UgPSBjdWJlLkZSdG9CUigpIC8gTl9TTElDRTIgfCAwO1xuICAgICAgICAvLyBQaGFzZSAyIGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMucGFyaXR5ID0gY3ViZS5jb3JuZXJQYXJpdHkoKTtcbiAgICAgICAgdGhpcy5VUkZ0b0RMRiA9IGN1YmUuVVJGdG9ETEYoKTtcbiAgICAgICAgdGhpcy5GUnRvQlIgPSBjdWJlLkZSdG9CUigpO1xuICAgICAgICAvLyBUaGVzZSBhcmUgbGF0ZXIgbWVyZ2VkIHRvIFVSdG9ERiB3aGVuIHBoYXNlIDIgYmVnaW5zXG4gICAgICAgIHRoaXMuVVJ0b1VMID0gY3ViZS5VUnRvVUwoKTtcbiAgICAgICAgdGhpcy5VQnRvREYgPSBjdWJlLlVCdG9ERigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgc29sdXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5zb2x1dGlvbigpICsgbW92ZU5hbWVzW3RoaXMubGFzdE1vdmVdICsgJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyMgSGVscGVyc1xuICAgICAgbW92ZSh0YWJsZSwgaW5kZXgsIG1vdmUpIHtcbiAgICAgICAgcmV0dXJuIEN1YmUubW92ZVRhYmxlc1t0YWJsZV1baW5kZXhdW21vdmVdO1xuICAgICAgfVxuXG4gICAgICBwcnVuaW5nKHRhYmxlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gcHJ1bmluZyhDdWJlLnBydW5pbmdUYWJsZXNbdGFibGVdLCBpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIC8vIyBQaGFzZSAxXG5cbiAgICAgIC8vIFJldHVybiB0aGUgbmV4dCB2YWxpZCBwaGFzZSAxIG1vdmVzIGZvciB0aGlzIHN0YXRlXG4gICAgICBtb3ZlczEoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RNb3ZlICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRNb3ZlczFbdGhpcy5sYXN0TW92ZSAvIDMgfCAwXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYWxsTW92ZXMxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIG1vdmVzIHRvIHRoZSBlbmQgb2YgcGhhc2UgMVxuICAgICAgbWluRGlzdDEoKSB7XG4gICAgICAgIHZhciBkMSwgZDI7XG4gICAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtb3ZlcyB0byB0aGUgZW5kIG9mIHBoYXNlIDEgd3J0LiB0aGVcbiAgICAgICAgLy8gY29tYmluYXRpb24gZmxpcCBhbmQgc2xpY2UgY29vcmRpbmF0ZXMgb25seVxuICAgICAgICBkMSA9IHRoaXMucHJ1bmluZygnc2xpY2VGbGlwJywgTl9TTElDRTEgKiB0aGlzLmZsaXAgKyB0aGlzLnNsaWNlKTtcbiAgICAgICAgLy8gVGhlIGNvbWJpbmF0aW9uIG9mIHR3aXN0IGFuZCBzbGljZSBjb29yZGluYXRlc1xuICAgICAgICBkMiA9IHRoaXMucHJ1bmluZygnc2xpY2VUd2lzdCcsIE5fU0xJQ0UxICogdGhpcy50d2lzdCArIHRoaXMuc2xpY2UpO1xuICAgICAgICAvLyBUaGUgdHJ1ZSBtaW5pbWFsIGRpc3RhbmNlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZXNlIHR3b1xuICAgICAgICByZXR1cm4gbWF4KGQxLCBkMik7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIG5leHQgcGhhc2UgMSBzdGF0ZSBmb3IgdGhlIGdpdmVuIG1vdmVcbiAgICAgIG5leHQxKG1vdmUpIHtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIG5leHQgPSBmcmVlU3RhdGVzLnBvcCgpO1xuICAgICAgICBuZXh0LnBhcmVudCA9IHRoaXM7XG4gICAgICAgIG5leHQubGFzdE1vdmUgPSBtb3ZlO1xuICAgICAgICBuZXh0LmRlcHRoID0gdGhpcy5kZXB0aCArIDE7XG4gICAgICAgIG5leHQuZmxpcCA9IHRoaXMubW92ZSgnZmxpcCcsIHRoaXMuZmxpcCwgbW92ZSk7XG4gICAgICAgIG5leHQudHdpc3QgPSB0aGlzLm1vdmUoJ3R3aXN0JywgdGhpcy50d2lzdCwgbW92ZSk7XG4gICAgICAgIG5leHQuc2xpY2UgPSB0aGlzLm1vdmUoJ0ZSdG9CUicsIHRoaXMuc2xpY2UgKiAyNCwgbW92ZSkgLyAyNCB8IDA7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuXG4gICAgICAvLyMgUGhhc2UgMlxuXG4gICAgICAvLyBSZXR1cm4gdGhlIG5leHQgdmFsaWQgcGhhc2UgMiBtb3ZlcyBmb3IgdGhpcyBzdGF0ZVxuICAgICAgbW92ZXMyKCkge1xuICAgICAgICBpZiAodGhpcy5sYXN0TW92ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBuZXh0TW92ZXMyW3RoaXMubGFzdE1vdmUgLyAzIHwgMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGFsbE1vdmVzMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb21wdXRlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBtb3ZlcyB0byB0aGUgc29sdmVkIGN1YmVcbiAgICAgIG1pbkRpc3QyKCkge1xuICAgICAgICB2YXIgZDEsIGQyLCBpbmRleDEsIGluZGV4MjtcbiAgICAgICAgaW5kZXgxID0gKE5fU0xJQ0UyICogdGhpcy5VUnRvREYgKyB0aGlzLkZSdG9CUikgKiBOX1BBUklUWSArIHRoaXMucGFyaXR5O1xuICAgICAgICBkMSA9IHRoaXMucHJ1bmluZygnc2xpY2VVUnRvREZQYXJpdHknLCBpbmRleDEpO1xuICAgICAgICBpbmRleDIgPSAoTl9TTElDRTIgKiB0aGlzLlVSRnRvRExGICsgdGhpcy5GUnRvQlIpICogTl9QQVJJVFkgKyB0aGlzLnBhcml0eTtcbiAgICAgICAgZDIgPSB0aGlzLnBydW5pbmcoJ3NsaWNlVVJGdG9ETEZQYXJpdHknLCBpbmRleDIpO1xuICAgICAgICByZXR1cm4gbWF4KGQxLCBkMik7XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWxpemUgcGhhc2UgMiBjb29yZGluYXRlc1xuICAgICAgaW5pdDIodG9wID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIG90aGVyIHN0YXRlcywgdGhlIHBoYXNlIDIgc3RhdGUgaXMgY29tcHV0ZWQgYmFzZWQgb25cbiAgICAgICAgLy8gcGFyZW50J3Mgc3RhdGUuXG4gICAgICAgIC8vIEFscmVhZHkgYXNzaWduZWQgZm9yIHRoZSBpbml0aWFsIHN0YXRlXG4gICAgICAgIHRoaXMucGFyZW50LmluaXQyKGZhbHNlKTtcbiAgICAgICAgdGhpcy5VUkZ0b0RMRiA9IHRoaXMubW92ZSgnVVJGdG9ETEYnLCB0aGlzLnBhcmVudC5VUkZ0b0RMRiwgdGhpcy5sYXN0TW92ZSk7XG4gICAgICAgIHRoaXMuRlJ0b0JSID0gdGhpcy5tb3ZlKCdGUnRvQlInLCB0aGlzLnBhcmVudC5GUnRvQlIsIHRoaXMubGFzdE1vdmUpO1xuICAgICAgICB0aGlzLnBhcml0eSA9IHRoaXMubW92ZSgncGFyaXR5JywgdGhpcy5wYXJlbnQucGFyaXR5LCB0aGlzLmxhc3RNb3ZlKTtcbiAgICAgICAgdGhpcy5VUnRvVUwgPSB0aGlzLm1vdmUoJ1VSdG9VTCcsIHRoaXMucGFyZW50LlVSdG9VTCwgdGhpcy5sYXN0TW92ZSk7XG4gICAgICAgIHRoaXMuVUJ0b0RGID0gdGhpcy5tb3ZlKCdVQnRvREYnLCB0aGlzLnBhcmVudC5VQnRvREYsIHRoaXMubGFzdE1vdmUpO1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgaW5pdGlhbCBwaGFzZSAyIHN0YXRlLiBHZXQgdGhlIFVSdG9ERiBjb29yZGluYXRlXG4gICAgICAgICAgLy8gYnkgbWVyZ2luZyBVUnRvVUwgYW5kIFVCdG9ERlxuICAgICAgICAgIHJldHVybiB0aGlzLlVSdG9ERiA9IHRoaXMubW92ZSgnbWVyZ2VVUnRvREYnLCB0aGlzLlVSdG9VTCwgdGhpcy5VQnRvREYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIG5leHQgcGhhc2UgMiBzdGF0ZSBmb3IgdGhlIGdpdmVuIG1vdmVcbiAgICAgIG5leHQyKG1vdmUpIHtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIG5leHQgPSBmcmVlU3RhdGVzLnBvcCgpO1xuICAgICAgICBuZXh0LnBhcmVudCA9IHRoaXM7XG4gICAgICAgIG5leHQubGFzdE1vdmUgPSBtb3ZlO1xuICAgICAgICBuZXh0LmRlcHRoID0gdGhpcy5kZXB0aCArIDE7XG4gICAgICAgIG5leHQuVVJGdG9ETEYgPSB0aGlzLm1vdmUoJ1VSRnRvRExGJywgdGhpcy5VUkZ0b0RMRiwgbW92ZSk7XG4gICAgICAgIG5leHQuRlJ0b0JSID0gdGhpcy5tb3ZlKCdGUnRvQlInLCB0aGlzLkZSdG9CUiwgbW92ZSk7XG4gICAgICAgIG5leHQucGFyaXR5ID0gdGhpcy5tb3ZlKCdwYXJpdHknLCB0aGlzLnBhcml0eSwgbW92ZSk7XG4gICAgICAgIG5leHQuVVJ0b0RGID0gdGhpcy5tb3ZlKCdVUnRvREYnLCB0aGlzLlVSdG9ERiwgbW92ZSk7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuXG4gICAgfTtcbiAgICBzb2x1dGlvbiA9IG51bGw7XG4gICAgcGhhc2Uxc2VhcmNoID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBkZXB0aCwgbSwgcmVmLCByZXN1bHRzO1xuICAgICAgZGVwdGggPSAwO1xuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChkZXB0aCA9IG0gPSAxLCByZWYgPSBtYXhEZXB0aDsgKDEgPD0gcmVmID8gbSA8PSByZWYgOiBtID49IHJlZik7IGRlcHRoID0gMSA8PSByZWYgPyArK20gOiAtLW0pIHtcbiAgICAgICAgcGhhc2UxKHN0YXRlLCBkZXB0aCk7XG4gICAgICAgIGlmIChzb2x1dGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMucHVzaChkZXB0aCsrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgcGhhc2UxID0gZnVuY3Rpb24oc3RhdGUsIGRlcHRoKSB7XG4gICAgICB2YXIgbGVuLCBtLCBtb3ZlLCBuZXh0LCByZWYsIHJlZjEsIHJlc3VsdHM7XG4gICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgaWYgKHN0YXRlLm1pbkRpc3QxKCkgPT09IDApIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3Qgc3RhcnQgcGhhc2UgMiB3aXRoIGEgcGhhc2UgMiBtb3ZlIGFzIHRoZVxuICAgICAgICAgIC8vIGxhc3QgbW92ZSBpbiBwaGFzZSAxLCBiZWNhdXNlIHBoYXNlIDIgd291bGQgdGhlbiByZXBlYXQgdGhlXG4gICAgICAgICAgLy8gc2FtZSBtb3ZlLlxuICAgICAgICAgIGlmIChzdGF0ZS5sYXN0TW92ZSA9PT0gbnVsbCB8fCAocmVmID0gc3RhdGUubGFzdE1vdmUsIGluZGV4T2YuY2FsbChhbGxNb3ZlczIsIHJlZikgPCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBoYXNlMnNlYXJjaChzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlcHRoID4gMCkge1xuICAgICAgICBpZiAoc3RhdGUubWluRGlzdDEoKSA8PSBkZXB0aCkge1xuICAgICAgICAgIHJlZjEgPSBzdGF0ZS5tb3ZlczEoKTtcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChtID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IG0gPCBsZW47IG0rKykge1xuICAgICAgICAgICAgbW92ZSA9IHJlZjFbbV07XG4gICAgICAgICAgICBuZXh0ID0gc3RhdGUubmV4dDEobW92ZSk7XG4gICAgICAgICAgICBwaGFzZTEobmV4dCwgZGVwdGggLSAxKTtcbiAgICAgICAgICAgIGZyZWVTdGF0ZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgIGlmIChzb2x1dGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcGhhc2Uyc2VhcmNoID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBkZXB0aCwgbSwgcmVmLCByZXN1bHRzO1xuICAgICAgLy8gSW5pdGlhbGl6ZSBwaGFzZSAyIGNvb3JkaW5hdGVzXG4gICAgICBzdGF0ZS5pbml0MigpO1xuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChkZXB0aCA9IG0gPSAxLCByZWYgPSBtYXhEZXB0aCAtIHN0YXRlLmRlcHRoOyAoMSA8PSByZWYgPyBtIDw9IHJlZiA6IG0gPj0gcmVmKTsgZGVwdGggPSAxIDw9IHJlZiA/ICsrbSA6IC0tbSkge1xuICAgICAgICBwaGFzZTIoc3RhdGUsIGRlcHRoKTtcbiAgICAgICAgaWYgKHNvbHV0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cy5wdXNoKGRlcHRoKyspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBwaGFzZTIgPSBmdW5jdGlvbihzdGF0ZSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW4sIG0sIG1vdmUsIG5leHQsIHJlZiwgcmVzdWx0cztcbiAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICBpZiAoc3RhdGUubWluRGlzdDIoKSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzb2x1dGlvbiA9IHN0YXRlLnNvbHV0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGVwdGggPiAwKSB7XG4gICAgICAgIGlmIChzdGF0ZS5taW5EaXN0MigpIDw9IGRlcHRoKSB7XG4gICAgICAgICAgcmVmID0gc3RhdGUubW92ZXMyKCk7XG4gICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAobSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IG0gPCBsZW47IG0rKykge1xuICAgICAgICAgICAgbW92ZSA9IHJlZlttXTtcbiAgICAgICAgICAgIG5leHQgPSBzdGF0ZS5uZXh0Mihtb3ZlKTtcbiAgICAgICAgICAgIHBoYXNlMihuZXh0LCBkZXB0aCAtIDEpO1xuICAgICAgICAgICAgZnJlZVN0YXRlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgaWYgKHNvbHV0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmcmVlU3RhdGVzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG0sIHJlZiwgcmVzdWx0cztcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoeCA9IG0gPSAwLCByZWYgPSBtYXhEZXB0aCArIDE7ICgwIDw9IHJlZiA/IG0gPD0gcmVmIDogbSA+PSByZWYpOyB4ID0gMCA8PSByZWYgPyArK20gOiAtLW0pIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBTdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KSgpO1xuICAgIHN0YXRlID0gZnJlZVN0YXRlcy5wb3AoKS5pbml0KHRoaXMpO1xuICAgIHBoYXNlMXNlYXJjaChzdGF0ZSk7XG4gICAgZnJlZVN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAvLyBUcmltIHRoZSB0cmFpbGluZyBzcGFjZVxuICAgIGlmIChzb2x1dGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICBzb2x1dGlvbiA9IHNvbHV0aW9uLnN1YnN0cmluZygwLCBzb2x1dGlvbi5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvbHV0aW9uO1xuICB9O1xuXG4gIGZhY2VOdW1zID0ge1xuICAgIFU6IDAsXG4gICAgUjogMSxcbiAgICBGOiAyLFxuICAgIEQ6IDMsXG4gICAgTDogNCxcbiAgICBCOiA1XG4gIH07XG5cbiAgZmFjZU5hbWVzID0ge1xuICAgIDA6ICdVJyxcbiAgICAxOiAnUicsXG4gICAgMjogJ0YnLFxuICAgIDM6ICdEJyxcbiAgICA0OiAnTCcsXG4gICAgNTogJ0InXG4gIH07XG5cbiAgQ3ViZS5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihtYXhEZXB0aCA9IDIyKSB7XG4gICAgdmFyIGNsb25lLCBsZW4sIG0sIG1vdmUsIHJlZiwgcm90YXRpb24sIHNvbHV0aW9uLCB1cHJpZ2h0LCB1cHJpZ2h0U29sdXRpb247XG4gICAgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgdXByaWdodCA9IGNsb25lLnVwcmlnaHQoKTtcbiAgICBjbG9uZS5tb3ZlKHVwcmlnaHQpO1xuICAgIHJvdGF0aW9uID0gbmV3IEN1YmUoKS5tb3ZlKHVwcmlnaHQpLmNlbnRlcjtcbiAgICB1cHJpZ2h0U29sdXRpb24gPSBjbG9uZS5zb2x2ZVVwcmlnaHQobWF4RGVwdGgpO1xuICAgIHNvbHV0aW9uID0gW107XG4gICAgcmVmID0gdXByaWdodFNvbHV0aW9uLnNwbGl0KCcgJyk7XG4gICAgZm9yIChtID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgbSA8IGxlbjsgbSsrKSB7XG4gICAgICBtb3ZlID0gcmVmW21dO1xuICAgICAgc29sdXRpb24ucHVzaChmYWNlTmFtZXNbcm90YXRpb25bZmFjZU51bXNbbW92ZVswXV1dXSk7XG4gICAgICBpZiAobW92ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNvbHV0aW9uW3NvbHV0aW9uLmxlbmd0aCAtIDFdICs9IG1vdmVbMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb2x1dGlvbi5qb2luKCcgJyk7XG4gIH07XG5cbiAgQ3ViZS5zY3JhbWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBDdWJlLmludmVyc2UoQ3ViZS5yYW5kb20oKS5zb2x2ZSgpKTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cubejs/lib/solve.js\n");

/***/ })

};
;